[{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Peter Solymos. Maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Solymos P, Azeria ET (2024). opticut: Likelihood Based Optimal Partitioning Indicator Species Analysis. R package version 0.1-3, https://github.com/psolymos/opticut.","code":"@Manual{,   title = {opticut: Likelihood Based Optimal Partitioning and Indicator Species Analysis},   author = {Peter Solymos and Ermias T. Azeria},   year = {2024},   note = {R package version 0.1-3},   url = {https://github.com/psolymos/opticut}, }"},{"path":"/index.html","id":"opticut-likelihood-based-optimal-partitioning-and-indicator-species-analysis","dir":"","previous_headings":"","what":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","text":"Likelihood based optimal partitioning indicator species analysis . Finding best binary partition species based model selection, possibly controlling modifying/confounding variables described Kemencei et al. (2014).","code":""},{"path":"/index.html","id":"versions","dir":"","previous_headings":"","what":"Versions","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","text":"Install stable version CRAN: Install development version GitHub: User visible changes package listed NEWS file.","code":"install.packages(\"opticut\") devtools::install_github(\"psolymos/opticut\")"},{"path":"/index.html","id":"report-a-problem","dir":"","previous_headings":"","what":"Report a problem","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","text":"Use issue tracker report problem.","code":""},{"path":"/index.html","id":"typical-workflow","dir":"","previous_headings":"","what":"Typical workflow","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","text":"","code":"library(opticut)  ## --- community data --- y <- cbind(     Sp1 = c(4,6,3,5, 5,6,3,4, 4,1,3,2),     Sp2 = c(0,0,0,0, 1,0,0,1, 4,2,3,4),     Sp3 = c(0,0,3,0, 2,3,0,5, 5,6,3,4))  ## --- stratification --- g <-      c(1,1,1,1, 2,2,2,2, 3,3,3,3)  ## --- find optimal partitions for each species --- oc <- opticut(y, strata = g, dist = \"poisson\") summary(oc) #  Multivariate opticut results, comb = rank, dist = poisson # #  Call: #  opticut.default(Y = y, strata = g, dist = \"poisson\") # #  Best supported models with logLR >= 2: #      split assoc      I  mu0  mu1 logLR      w #  Sp3   2 3    ++ 0.6471 0.75 3.50 4.793 0.6962 #  Sp2     3   +++ 0.8571 0.25 3.25 9.203 0.9577 #  2 binary splits #  1 species not shown  ## --- visualize the results --- plot(oc, cut = -Inf)  ## --- quantify uncertainty --- uc <- uncertainty(oc, type = \"asymp\", B = 999) summary(uc) #  Multivariate opticut uncertainty results #  type = asymp, B = 999, level = 0.95 # #      split R      I   Lower  Upper #  Sp1   1 2 1 0.2860 0.02341 0.5668 #  Sp3   2 3 1 0.6218 0.21456 0.8813 #  Sp2     3 1 0.8274 0.51229 0.9680"},{"path":"/index.html","id":"dynamic-documents-with-opticut","dir":"","previous_headings":"","what":"Dynamic documents with opticut","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","text":"minimal Rmarkdown example: Rmd source, knitted PDF.","code":""},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis","text":"Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, ., Hornung, E. & Solymos, P. (2014): Microhabitat associations land snails forested dolinas: implications coarse filter conservation. Community Ecology 15:180–186. [link, PDF]","code":""},{"path":"/reference/allComb.html","id":null,"dir":"Reference","previous_headings":"","what":"Finding All Possible Binary Partitions — allComb","title":"Finding All Possible Binary Partitions — allComb","text":"functions used find possible binary partitions. Finding combinations require classification vector K > 1 strata.","code":""},{"path":"/reference/allComb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finding All Possible Binary Partitions — allComb","text":"","code":"allComb(x, collapse) kComb(k) checkComb(x)"},{"path":"/reference/allComb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finding All Possible Binary Partitions — allComb","text":"x vector allComb (can type treated factor, must least 2 unique values); numeric matrix checkComb. collapse character, paste levels. Defaults getOption(\"ocoptions\")$collapse. k numeric, number levels (strata) given classification (K > 1).","code":""},{"path":"/reference/allComb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finding All Possible Binary Partitions — allComb","text":"kComb returns contrast matrix corresponding possible binary partitions factor K levels. Complements counted twice, .e. (0,0,1,1) equivalent (1,1,0,0). number possible combinations M = 2^(K - 1) - 1. allComb takes classification vector least 2 levels returns model matrix binary partitions. checkComb checks combinations unique non-complementary (misfits returned attributes). Returns logical value.","code":""},{"path":"/reference/allComb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finding All Possible Binary Partitions — allComb","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/allComb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finding All Possible Binary Partitions — allComb","text":"","code":"kComb(k = 2) #>      [,1] #> [1,]    1 #> [2,]    0 kComb(k = 3) #>      [,1] [,2] [,3] #> [1,]    1    0    0 #> [2,]    0    1    0 #> [3,]    0    0    1 kComb(k = 4) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]    1    0    0    0    1    1    1 #> [2,]    0    1    0    0    1    0    0 #> [3,]    0    0    1    0    0    1    0 #> [4,]    0    0    0    1    0    0    1  ## finding all combinations (f <- rep(LETTERS[1:4], each=2)) #> [1] \"A\" \"A\" \"B\" \"B\" \"C\" \"C\" \"D\" \"D\" (mc <- allComb(f, collapse = \"_\")) #>   A B C D A_B A_C A_D #> A 1 0 0 0   1   1   1 #> A 1 0 0 0   1   1   1 #> B 0 1 0 0   1   0   0 #> B 0 1 0 0   1   0   0 #> C 0 0 1 0   0   1   0 #> C 0 0 1 0   0   1   0 #> D 0 0 0 1   0   0   1 #> D 0 0 0 1   0   0   1 #> attr(,\"collapse\") #> [1] \"_\" #> attr(,\"comb\") #> [1] \"all\" ## checking for complementary entries checkComb(mc) # TRUE #> [1] TRUE #> attr(,\"comp\") #>      i j #> attr(,\"same\") #>      i j ## adding complementary entries to the matrix mc2 <- cbind(z = 1 - mc[,1], mc[,c(1:ncol(mc), 1)]) colnames(mc2) <- 1:ncol(mc2) mc2 #>   1 2 3 4 5 6 7 8 9 #> A 0 1 0 0 0 1 1 1 1 #> A 0 1 0 0 0 1 1 1 1 #> B 1 0 1 0 0 1 0 0 0 #> B 1 0 1 0 0 1 0 0 0 #> C 1 0 0 1 0 0 1 0 0 #> C 1 0 0 1 0 0 1 0 0 #> D 1 0 0 0 1 0 0 1 0 #> D 1 0 0 0 1 0 0 1 0 checkComb(mc2) # FALSE #> [1] FALSE #> attr(,\"comp\") #>      i j #> [1,] 1 2 #> [2,] 1 9 #> attr(,\"same\") #>      i j #> [1,] 9 2"},{"path":"/reference/bestmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Best model, Partition, and MLE — bestmodel","title":"Best model, Partition, and MLE — bestmodel","text":"Generic functions accessing best model, best partition, Maximum Likelihood Estimate fitted objects.","code":""},{"path":"/reference/bestmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Best model, Partition, and MLE — bestmodel","text":"","code":"bestmodel(object, ...) bestpart(object, ...) getMLE(object, ...)"},{"path":"/reference/bestmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Best model, Partition, and MLE — bestmodel","text":"object fitted model object. ... arguments passed underlying functions.","code":""},{"path":"/reference/bestmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Best model, Partition, and MLE — bestmodel","text":"bestmodel returns best supported model manipulation (e.g. prediction). bestpart returns matrix best supported partitions species (species columns). getMLE returns named list corresponding best supported model. list following elements: coef Maximum Likelihood Estimate (MLE), vcov variance-covariance matrix MLE, dist distribution inherited input object.","code":""},{"path":"/reference/bestmodel.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Best model, Partition, and MLE — bestmodel","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/beta2i.html","id":null,"dir":"Reference","previous_headings":"","what":"Scaling for the Indicator Potential — beta2i","title":"Scaling for the Indicator Potential — beta2i","text":"Transformation estimated contrasts indicator potential.","code":""},{"path":"/reference/beta2i.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scaling for the Indicator Potential — beta2i","text":"","code":"beta2i(x, scale = 1)"},{"path":"/reference/beta2i.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scaling for the Indicator Potential — beta2i","text":"x numeric, real valued coefficients. scale numeric, scaling constant.","code":""},{"path":"/reference/beta2i.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scaling for the Indicator Potential — beta2i","text":"Returns numeric vector (= abs(tanh(x * scale))).","code":""},{"path":"/reference/beta2i.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Scaling for the Indicator Potential — beta2i","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/beta2i.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scaling for the Indicator Potential — beta2i","text":"","code":"x <- seq(-5, 5, 0.1) Col <- occolors(c(\"red\", \"blue\"))(10) plot(x, beta2i(x), type = \"n\") s <- seq(1, 0.1, -0.1) for (i in 1:10) {     lines(x, beta2i(x, scale = s[i]), col = Col[i])     text(1.5 - 0.2, beta2i(1.5, scale = s[i]), s[i], col = Col[i]) }"},{"path":"/reference/birdrec.html","id":null,"dir":"Reference","previous_headings":"","what":"Bird Species Detections — birdrec","title":"Bird Species Detections — birdrec","text":"Data set listing 156 species (mostly birds, amphibians mammals) detected 127 sites (367 point locations) Alberta, Canada 2015, using autonomous recording technology (ARU; Wildlife Acoustic Song Meter) sound recordings.","code":""},{"path":"/reference/birdrec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bird Species Detections — birdrec","text":"","code":"data(\"birdrec\")"},{"path":"/reference/birdrec.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Bird Species Detections — birdrec","text":"list 3 elements matching ordering: xtab sample x species matrix number detections, samp data frame sample level attributes. taxa data frame species level attributes. Multiple random recordings location selected according stratified random design (based combination TOY TOD). recordings listened trained analysts species identified based auditory cues. data set lists detections first 1-minute segment recording. Dates 3967 1-minute segments range 2015-03-31 2015-07-29. Variables birdrec$samp following: PKEY: primary key location/time combinations. POINT: unique spatial location IDs, point ARU unit. SITE: site ID (1-4 ARU units deployed per site). YEAR: year, 2015. MONTH: month 3 (March) 7 (July). MDAY: day month, 1-31. HOUR: 24-hour day, values 0-12. MINUTE: minute, 0-59. YDAY: ordinal day year, 89-209. RAIN, WIND, INDUSTRY, NOISE: level rain, wind, industrial noise, background noise. 0 = ; 1 = light; 2 = moderate; 3 = heavy. MICROPHONE: Every recording contains certain level background static due pre-amplifiers; however, problems, , electrostatic discharge microphones, faulty wiring, poorly installed microphones /missing microphones can occur causing excess static dead channels. 0 = microphone related issues; 1 = left microphone cuts intermittently; 2 = right microphone cuts intermittently; 3 = microphones cut intermittently; 4 = left channel failed; 5 = right channel failed; 6 = channels failed (cases data set); 7 = left side extra static; 8 = right side extra static; 9 = sides extra static; 10 = issues; 11 = unbalanced channels. TOY: time year intervals used stratified random selection dates. 8 intervals divided 3 major units (early, mid, late breeding season; YDAY 140 180 used threshold major units). TOD: time day, midnight (HOUR = 0) morning (HOUR > 0). Variables birdrec$taxa following: Species, CommonName, ScientificName, Family, Order, Class, MigratoryBehaviour. Methodology metadata described ABMI (2016), Lankau et al. (2015).","code":""},{"path":"/reference/birdrec.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Bird Species Detections — birdrec","text":"Alberta Biodiversity Monitoring Institute (ABMI, www.abmi.ca)","code":""},{"path":"/reference/birdrec.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bird Species Detections — birdrec","text":"Alberta Biodiversity Monitoring Institute (ABMI), 2016. Terrestrial field data collection protocols (abridged version) 2016-05-18. Alberta Biodiversity Monitoring Institute; Edmonton, Alberta, Canada. Lankau, H.E., MacPhail, ., Knaggs, M. & Bayne, E., 2015. Acoustic recording analysis protocol. Bioacoustic Unit, University Alberta, Alberta Biodiversity Monitoring Institute; Edmonton, Alberta, Canada.","code":""},{"path":"/reference/birdrec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bird Species Detections — birdrec","text":"","code":"data(birdrec) str(birdrec) #> List of 3 #>  $ xtab: int [1:3967, 1:156] 0 0 0 0 0 0 0 0 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:3967] \"T_IG_ABMI_388_2015_1_STATION_NW_89:0:0\" \"T_IG_ABMI_599_2015_1_STATION_NE_89:0:0\" \"T_IG_ABMI_855_2015_1_STATION_NW_89:0:0\" \"T_IG_ABMI_855_2015_1_STATION_SE_89:0:0\" ... #>   .. ..$ : chr [1:156] \"AlderFlycatcher\" \"AmericanBittern\" \"AmericanCoot\" \"AmericanCrow\" ... #>  $ samp:'data.frame':\t3967 obs. of  16 variables: #>   ..$ PKEY      : Factor w/ 3967 levels \"T_IG_ABMI_388_2015_1_STATION_NW_89:0:0\",..: 1 2 3 4 5 6 7 8 9 10 ... #>   ..$ POINT     : Factor w/ 367 levels \"T_IG_ABMI_1_2015_1_STATION_NE\",..: 120 197 258 259 81 142 200 230 30 57 ... #>   ..$ SITE      : Factor w/ 124 levels \"1\",\"1022\",\"1023\",..: 31 51 67 67 21 37 51 59 8 15 ... #>   ..$ YEAR      : int [1:3967] 2015 2015 2015 2015 2015 2015 2015 2015 2015 2015 ... #>   ..$ MONTH     : int [1:3967] 3 3 3 3 4 4 4 4 4 4 ... #>   ..$ MDAY      : int [1:3967] 31 31 31 31 1 1 1 1 2 2 ... #>   ..$ HOUR      : int [1:3967] 0 0 0 0 0 0 0 0 0 0 ... #>   ..$ MINUTE    : int [1:3967] 0 0 0 0 0 0 0 0 0 0 ... #>   ..$ YDAY      : int [1:3967] 89 89 89 89 90 90 90 90 91 91 ... #>   ..$ RAIN      : int [1:3967] 0 0 0 0 0 0 0 0 0 0 ... #>   ..$ WIND      : int [1:3967] 1 0 0 0 2 1 1 2 0 1 ... #>   ..$ INDUSTRY  : int [1:3967] 2 1 0 0 0 2 1 2 1 0 ... #>   ..$ NOISE     : int [1:3967] 2 0 0 0 0 0 0 0 0 0 ... #>   ..$ MICROPHONE: int [1:3967] 0 0 0 0 0 7 0 0 0 0 ... #>   ..$ TOY       : Factor w/ 8 levels \"Early1\",\"Early2\",..: 1 1 1 1 1 1 1 1 1 1 ... #>   ..$ TOD       : Factor w/ 2 levels \"Morning\",\"Midnight\": 2 2 2 2 2 2 2 2 2 2 ... #>  $ taxa:'data.frame':\t156 obs. of  7 variables: #>   ..$ Species           : Factor w/ 156 levels \"AlderFlycatcher\",..: 1 2 3 4 5 6 7 8 145 9 ... #>   ..$ CommonName        : Factor w/ 156 levels \"Alder Flycatcher\",..: 1 2 3 4 5 6 7 8 145 9 ... #>   ..$ ScientificName    : Factor w/ 156 levels \"Acanthis flammea\",..: 47 20 54 42 116 53 109 134 153 117 ... #>   ..$ Family            : Factor w/ 43 levels \" Vespertilionidae\",..: 40 4 31 14 17 16 27 39 29 15 ... #>   ..$ Order             : Factor w/ 18 levels \"Anseriformes\",..: 12 13 11 12 12 8 12 12 14 12 ... #>   ..$ Class             : Factor w/ 3 levels \"Amphibia\",\"Aves\",..: 2 2 2 2 2 2 2 2 2 2 ... #>   ..$ MigratoryBehaviour: Factor w/ 3 levels \"Neotropical migrant\",..: 1 2 2 2 2 2 1 2 3 2 ...  aggregate(rowSums(birdrec$xtab),     list(TOY=birdrec$samp$TOY, TOD=birdrec$samp$TOD), mean) #>       TOY      TOD         x #> 1  Early1  Morning 0.7073171 #> 2  Early2  Morning 1.7207207 #> 3  Early3  Morning 4.7593052 #> 4    Mid4  Morning 6.2938005 #> 5    Mid5  Morning 6.8922652 #> 6    Mid6  Morning 5.8924419 #> 7    Mid7  Morning 6.0426136 #> 8   Late8  Morning 4.0459364 #> 9  Early1 Midnight 0.3896104 #> 10 Early2 Midnight 0.8431373 #> 11 Early3 Midnight 1.2451613 #> 12   Mid4 Midnight 1.0800000 #> 13   Mid5 Midnight 1.3566879 #> 14   Mid6 Midnight 1.1585366 #> 15   Mid7 Midnight 1.0639535 #> 16  Late8 Midnight 0.5560748 boxplot(rowSums(birdrec$xtab) ~ TOD + TOY, birdrec$samp,     col=c(\"gold\", \"tomato\"), ylab=\"# detections\")   if (FALSE) { y <- ifelse(birdrec$xtab > 0, 1, 0) g <- paste0(gsub(\"[[:digit:]]\", \"\", as.character(birdrec$samp$TOY)),     substr(as.character(birdrec$samp$TOD), 1, 4)) g <- factor(g, levels=c(\"EarlyMorn\", \"MidMorn\", \"LateMorn\",     \"EarlyMidn\", \"MidMidn\", \"LateMidn\")) ## binary response model oc <- opticut(y ~ 1, strata=g, dist=\"binomial\") ## multi-level response model mc <- multicut(y ~ 1, strata=g, dist=\"binomial\")  ## testing equality of labels splito <- as.character(summary(oc)$summary$split) splitm <- as.character(summary(mc)$summary$split) table(splito == splitm) ## seeing how much those differ bpo <- summary(oc)$bestpart bpm <- summary(mc)$bestpart rs <- rowSums(abs(bpo-bpm)) table(rs) 10 * bpo[rs > 0,] + bpm[rs > 0,] }"},{"path":"/reference/dolina.html","id":null,"dir":"Reference","previous_headings":"","what":"Land Snail Data Set — dolina","title":"Land Snail Data Set — dolina","text":"comprehensive micro-scale land snail data set 16 dolinas Aggtelek Karst Area, Hungary. Data set containing land snail counts described Kemecei et al. 2014.","code":""},{"path":"/reference/dolina.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Land Snail Data Set — dolina","text":"","code":"data(\"dolina\")"},{"path":"/reference/dolina.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Land Snail Data Set — dolina","text":"list 3 elements: xtab sample x species matrix counts, samp data frame sample level attributes, taxa data frame scientific names families species. Land snails sampled daylight hours 16 18 August, 2007. Samples taken four microhabitat types (dolina$samp$microhab, dolina$samp$mhab): litter (LI), trunks live trees (TL), dead wood (also known coarse woody debris; DW), rock (RO). 16 dolina (dolina$samp$dolina), seven samples collected litter microhabitat along north-south transect. case three microhabitat types, samples collected three random locations per microhabitat type dolina. total 256 samples (dolina$samp$sample) collected, consisting 2 sub-samples collected 2 sampling methods (dolina$samp$method): litter samples (Q) timed search (T). One liter litter samples including topsoil collected examined later laboratory. Litter samples collected adjacent live wood, dead wood rocks, wood rocks . Litter samples litter microhabitat collected near wood rocks (minimum distance 2 meters). 5 minutes per site time-restricted direct search investigated microhabitats 1 meter radius circle around litter sample location, also including tree rock surfaces microhabitats. vertical zone (dolina$samp$stratum, bottom, middle edge dolinas), aspect sample locations (dolina$samp$aspect), along litter depth (dolina$samp$lthick, cm), litter moisture (dolina$samp$lmoist, scored ordinal scale: 1=dry, 2=fresh, 3=moist) also recorded. Distinction live animals versus fresh empty shells feasible due method sorting dry material delay litter sample processing, combined constituted 'fresh' group. Whitened, disintegrating broken shells constituted 'broken' group. 'broken' group excluded data set presented .","code":""},{"path":"/reference/dolina.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Land Snail Data Set — dolina","text":"Solymos et al. 2016 Kemencei et al. 2014.","code":""},{"path":"/reference/dolina.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Land Snail Data Set — dolina","text":"Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, ., Hornung, E. & Solymos, P., 2014. Microhabitat associations land snails forested dolinas: implications coarse filter conservation. Community Ecology 15:180--186. <doi:10.1556/ComEc.15.2014.2.6> Solymos, P., Kemencei, Z. Pall-Gergely, B., Farkas, R., Vilisics, F., Nagy, ., Kisfali, M. & Hornung, E., 2016. Public data dolina project. Version 1.0. Zenodo, <doi:10.5281/zenodo.53080>","code":""},{"path":"/reference/dolina.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Land Snail Data Set — dolina","text":"","code":"data(dolina) str(dolina) #> List of 3 #>  $ xtab: num [1:512, 1:42] 0 0 0 0 0 0 0 0 0 0 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:512] \"10A1Q\" \"10A1T\" \"10A2Q\" \"10A2T\" ... #>   .. ..$ : chr [1:42] \"aacu\" \"amin\" \"apol\" \"apur\" ... #>  $ samp:'data.frame':\t512 obs. of  9 variables: #>   ..$ sample  : Factor w/ 256 levels \"10A1\",\"10A2\",..: 1 1 2 2 3 3 4 4 5 5 ... #>   ..$ dolina  : int [1:512] 10 10 10 10 10 10 10 10 10 10 ... #>   ..$ microhab: Factor w/ 4 levels \"dead.wood\",\"litter\",..: 2 2 2 2 2 2 2 2 2 2 ... #>   ..$ mhab    : Factor w/ 4 levels \"LI\",\"DW\",\"TL\",..: 1 1 1 1 1 1 1 1 1 1 ... #>   ..$ method  : Factor w/ 2 levels \"Q\",\"T\": 1 2 1 2 1 2 1 2 1 2 ... #>   ..$ aspect  : Factor w/ 5 levels \"eastern\",\"flat\",..: 4 4 4 4 4 4 2 2 3 3 ... #>   ..$ stratum : Factor w/ 4 levels \"1bottom\",\"2middle\",..: 4 4 3 3 2 2 1 1 2 2 ... #>   ..$ lmoist  : num [1:512] 1 1 1 1 1 1 1.5 1.5 1 1 ... #>   ..$ lthick  : num [1:512] 2 2 2.5 2.5 3 3 0.5 0.5 1.5 1.5 ... #>  $ taxa:'data.frame':\t42 obs. of  2 variables: #>   ..$ scientific.name: Factor w/ 42 levels \"Acanthinula aculeata\",..: 1 2 32 3 4 5 10 8 13 11 ... #>   ..$ family         : Factor w/ 17 levels \"Aciculidae\",\"Carychiidae\",..: 16 10 1 10 3 3 3 3 17 3 ...  ## species richness by microhabitat and method Richness <- rowSums(dolina$xtab > 0) boxplot(Richness ~ mhab + method, dolina$samp,     ylab=\"Species richness\", main=\"Dolina data set\",     col=rep(c(\"#2C7BB6\", \"#D7191C\"), each=4))"},{"path":"/reference/lorenz.html","id":null,"dir":"Reference","previous_headings":"","what":"Lorenz Curve Based Thresholds and Partitions — lorenz","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"Lorenz curve based thresholds partitions.","code":""},{"path":"/reference/lorenz.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"","code":"lorenz(x, n = rep(1, length(x)), na.last = TRUE)  # S3 method for lorenz quantile(x, probs = seq(0, 1, 0.25),     type = c(\"L\", \"p\"), ...) iquantile(x, ...) # S3 method for lorenz iquantile(x, values,     type = c(\"L\", \"p\"),...)  # S3 method for lorenz plot(x, type = c(\"L\", \"x\"),     tangent = NA, h = NA, v = NA, ...)  # S3 method for summary.lorenz print(x, digits, ...) # S3 method for lorenz summary(object, ...)"},{"path":"/reference/lorenz.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"x vector nonnegative numbers lorenz, object plot summarized. n vector frequencies, must length x. na.last logical, controlling treatment NAs. TRUE, missing values data put last; FALSE, put first; NA, removed (see order). probs numeric vector probabilities values [0,1], quantile. values numeric vector values corresponding population quantiles returned. type character. plot method indicates whether plot cumulative distribution quantiles (\"L\") ordered -cumulated values (\"x\"). quantile iquantile methods indicates quantiles (\"L\" \"p\") use. tangent color value Lorenz-curve tangent plotted. default NA value omits tangent plot. h color value horizontal line Lorenz-curve tangent plotted. default NA value omits horizontal line plot. v color value vertical line Lorenz-curve tangent plotted. default NA value omits vertical line plot. digits numeric, number significant digits output. object object summarize. ... arguments passed underlying functions.","code":""},{"path":"/reference/lorenz.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"Lorenz curve continuous piecewise linear function representing distribution abundance (income, wealth). Cumulative portion population: \\(p_i = / m\\) (\\(=1,...,m\\)), vs. cumulative portion abundance: \\(L_i = \\sum_{j=1}^{} x_j * n_j / \\sum_{j=1}^{n} x_j * n_j\\). \\(x_i\\) indexed non-decreasing order (\\(x_i <= x_{+1}\\)). convention, p_0 = L_0 = 0. n can represent unequal frequencies. following charactersitics Lorenz curve calculated: \"t\": index tangent (slope 1) touches curve; \"x[t]\", \"p[t]\", \"L[t]\" values corresponding index t, x_t unmodified input. \"S\": Lorenz asymmetry coefficient (\\(S = p_t + L_t\\)), \\(S = 1\\) indicates symmetry. \"G\": Gini coefficient, 0 perfect equality,   values close 1 indicate high inequality. \"J\": Youden index (largest) distance anti-diagonal curve, distance largest tangent point (\\(J = max(p - L) = p_t - L_t\\)).","code":""},{"path":"/reference/lorenz.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"lorenz returns object class lorenz. matrix m+1 rows (m = length(x)) 3 columns (p, L, x). quantile method finds values x_i corresponding quantiles L_i p_i (depending type argument). iquantile (inverse quantile) method finds quantiles L_i p_i corresponding values x_i. plot method draws Lorenz curve. object matrix, lines points work adding multiple lines. summary method returns characteristics Lorenz curve.","code":""},{"path":"/reference/lorenz.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"Damgaard, C., & Weiner, J. (2000): Describing inequality plant size fecundity. Ecology 81:1139--1142. <doi:10.2307/177185> Schisterman, E. F., Perkins, N. J., Liu, ., & Bondell, H. (2005): Optimal cut-point corresponding Youden index discriminate individuals using pooled blood samples. Epidemiology 16:73--81. <doi:10.1097/01.ede.0000147512.81966.ba> Youden, W. J. (1950): Index rating diagnostic tests. Cancer 3:32--5. <doi:10.1002/1097-0142(1950)3:1<32::AID-CNCR2820030106>3.0.CO;2-3>","code":""},{"path":"/reference/lorenz.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/lorenz.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lorenz Curve Based Thresholds and Partitions — lorenz","text":"","code":"set.seed(1) x <- c(rexp(100, 10), rexp(200, 1))  l <- lorenz(x) head(l) #>                p            L           x #> [1,] 0.000000000 0.000000e+00 0.000000000 #> [2,] 0.003333333 8.256055e-06 0.001700975 #> [3,] 0.006666667 2.634516e-05 0.003726853 #> [4,] 0.010000000 4.819482e-05 0.004501631 #> [5,] 0.013333333 7.346108e-05 0.005205545 #> [6,] 0.016666667 1.008080e-04 0.005634216 tail(l) #>                p         L        x #> [296,] 0.9833333 0.8954549 3.173340 #> [297,] 0.9866667 0.9112748 3.259337 #> [298,] 0.9900000 0.9279782 3.441357 #> [299,] 0.9933333 0.9470105 3.921174 #> [300,] 0.9966667 0.9692697 4.586020 #> [301,] 1.0000000 1.0000000 6.331284 summary(l) #> Lorenz curve summary #>  #>   x[t]   p[t]   L[t]      G      S      J  #> 0.6827 0.6433 0.1934 0.5909 0.8367 0.4500  #>  summary(unclass(l)) #>        p              L                 x           #>  Min.   :0.00   Min.   :0.00000   Min.   :0.00000   #>  1st Qu.:0.25   1st Qu.:0.01708   1st Qu.:0.09968   #>  Median :0.50   Median :0.08771   Median :0.36917   #>  Mean   :0.50   Mean   :0.20551   Mean   :0.68448   #>  3rd Qu.:0.75   3rd Qu.:0.32198   3rd Qu.:1.01262   #>  Max.   :1.00   Max.   :1.00000   Max.   :6.33128    (q <- c(0.05, 0.5, 0.95)) #> [1] 0.05 0.50 0.95 (p_i <- quantile(l, probs=q, type=\"p\")) #>         5%        50%        95%  #> 0.02035104 0.36917103 2.25115270  iquantile(l, values=p_i, type=\"p\") #> 0.02035104 0.36917103 2.25115270  #>       0.05       0.50       0.95  (p_i <- quantile(l, probs=q, type=\"L\")) #>        5%       50%       95%  #> 0.2198279 1.4773854 4.5860202  iquantile(l, values=p_i, type=\"L\") #>  0.2198279  1.4773854  4.5860202  #> 0.05039184 0.50430635 0.96926972   op <- par(mfrow=c(2,1)) plot(l, lwd=2, tangent=2, h=3, v=4) abline(0, 1, lty=2, col=\"grey\") abline(1, -1, lty=2, col=\"grey\") plot(l, type=\"x\", lwd=2, h=3, v=4)  par(op)  ## Lorenz-tangent approach to binarize a multi-level problem n <- 100 g <- as.factor(sort(sample(LETTERS[1:4], n, replace=TRUE, prob=4:1))) x <- rpois(n, exp(as.integer(g))) mu <- aggregate(x, list(g), mean) (l <- lorenz(mu$x, table(g))) #>      p          L         x #>   0.00 0.00000000  0.000000 #> A 0.41 0.07932011  2.731707 #> B 0.70 0.22592068  7.137931 #> C 0.86 0.45467422 20.187500 #> D 1.00 1.00000000 55.000000 #> attr(,\"summary\") #>         t      x[t]      p[t]      L[t]         G         S         J  #> 3.0000000 7.1379310 0.7000000 0.2259207 0.3700425 0.9259207 0.4740793  #> attr(,\"class\") #> [1] \"lorenz\" \"matrix\" (s <- summary(l)) #> Lorenz curve summary #>  #>   x[t]   p[t]   L[t]      G      S      J  #> 7.1379 0.7000 0.2259 0.3700 0.9259 0.4741  #>   plot(l) abline(0, 1, lty=2) lines(rep(s[\"p[t]\"], 2), c(s[\"p[t]\"], s[\"L[t]\"]), col=2)"},{"path":"/reference/multicut.html","id":null,"dir":"Reference","previous_headings":"","what":"Multi-level Response Model — multicut","title":"Multi-level Response Model — multicut","text":"functions fits multi-level response model species, possibly controlling modifying/confounding variables.","code":""},{"path":"/reference/multicut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multi-level Response Model — multicut","text":"","code":"multicut1(Y, X, Z, dist = \"gaussian\", sset=NULL, ...)  multicut(...) # S3 method for default multicut(Y, X, strata, dist = \"gaussian\",     sset=NULL, cl = NULL, ...) # S3 method for formula multicut(formula, data, strata, dist = \"gaussian\",     sset=NULL, cl = NULL, ...)  # S3 method for multicut bestmodel(object, which = NULL, ...) # S3 method for multicut bestpart(object, ...) # S3 method for multicut strata(object, ...) # S3 method for multicut getMLE(object, which, vcov=FALSE, ...) # S3 method for multicut subset(x, subset=NULL, ...) # S3 method for multicut fitted(object, ...) # S3 method for multicut predict(object, gnew=NULL, xnew=NULL, ...)  # S3 method for multicut plot(x, which = NULL, cut, sort,     las, ylab = \"Relative abundance\", xlab = \"Strata\",     show_I = TRUE, show_S = TRUE, hr = TRUE, tick = TRUE,     theme, mar = c(5, 4, 4, 4) + 0.1, bty = \"o\",     lower = 0, upper = 1, pos = 0, horizontal=TRUE, ...) # S3 method for multicut1 plot(x,     ylab = \"Relative abundance\", xlab = \"Strata\", ...) lcplot(x, ...) # S3 method for multicut1 lcplot(x,     ylab=\"Cumulative abundance\", xlab=\"Strata\",     bty = \"o\", theme, ...)  # S3 method for multicut1 print(x, digits, ...) # S3 method for multicut print(x, digits, ...) # S3 method for summary.multicut print(x, cut, sort, digits, ...) # S3 method for multicut summary(object, ...)  # S3 method for multicut as.data.frame(x,     row.names = NULL, optional = FALSE, cut, sort, ...) # S3 method for summary.multicut as.data.frame(x,     row.names = NULL, optional = FALSE, cut, sort, ...)"},{"path":"/reference/multicut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multi-level Response Model — multicut","text":"formula two sided model formula, response species data (matrix, possible vector single species case) left-hand side, model terms modifying effects right-hand side (structure depending underlying functions). example, basic Gaussian case can y ~ 1 (modifying variables) y ~ x (modifying variables). Centering modifying terms (choosing origin wisely) generally recommended (especially Gaussian distribution linear predictors additive response scale) relative abundance contrasts estimated origin (0). data optional data frame, list environment containing variables model. found data, variables taken parent.frame(), typically environment multicut called. strata, Z factor, unique values define strata (must least 2 unique levels, empty levels dropped). dist character function, distribution fit. character, can follow one patterns: \"family\", \"family:link\" appropriate (link argument underlying function, link can specified via family argument). See Details opticut page Examples. sset optional vector specifying subset observations (rows) used fitting process. NULL means subset taken. cl cluster object, integer multiple cores parallel computations (integer value forking ignored Windows). Y numeric vector observations multicut1, vector community matrix multicut.default. X numeric, design matrix possible confounding/modifier variables. Can missing, case intercept-model assumed. x, object object plot, print, summarize. cut log likelihood ratio value used cut-showing species whose log likelihood ratio less cut-. sort logical value indicating species/partitions meaningfully sorted, default TRUE. can take numeric value species (1) partitions (2) sorted (1:2 equivalent TRUE). show_I logical, indicator potential () shown. show_S logical, number indicator species shown. hr, tick logical, horizontal rules (hr) ticks axis legends (tick) added. Default TRUE . theme color theme defined occolors. mar numeric, graphical parameters plot margin par. ylab, xlab, las graphical arguments, see plot. default, las 1 horizontal = TRUE 2 horizontal = FALSE. bty Character, determines type box drawn around plots, see par. lower, upper numeric (0 1), lower minimum upper maximum height rectangles drawn plot. need [0, 1] higher smaller lower. pos numeric, position rectangles plot relative baseline. Value must [-1, 1] range (vs. baseline). horizontal logical, plot orientation: species rows (TRUE) columns (FALSE). digits numeric, number significant digits output. numeric character (can vector) defining subset species fitted object, NULL (species, default). row.names NULL character vector giving row names data frame. Missing values allowed. See .data.frame. optional logical. TRUE, setting row names converting column names (syntactic names: see make.names) optional. See .data.frame. subset logical, numeric, character index indicating species keep, missing values accepted. default NULL returns original object without subsetting. vcov logical, variance-covariance matrix returned. gnew, xnew new values strata modifiers (right-hand-side formula) predict , NULL. ... arguments passed underlying functions.","code":""},{"path":"/reference/multicut.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Multi-level Response Model — multicut","text":"use multicut1 function generally discouraged: internal checks guaranteed flag issues formula--model-matrix translation side-stepped (happening modifier variables supplied X argument multicut1). Use multicut function single species instead.","code":""},{"path":"/reference/multicut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multi-level Response Model — multicut","text":"multicut1 returns object class 'multicut1'. multicut returns object class 'multicut', list following components: \"call\" function call. \"species\" list species specific multicut1 objects. \"X\" modifying variables model matrix. \"Y\" response, single species vector matrix. \"strata\" defines stratification. \"nobs\" sample size. \"sset\" subset, specified. \"dist\" distribution. \"failed\" IDs failed species models dropped results list. strata method extracts strata argument factor. print summary methods called side effects showing expected values, log likelihood ratio (logLR). Optimal binary partitions determined part summary based Lorenz-tangent based thresholding, requires nonnegative expected values. Indicator potential () based largest contrast (difference) minimum maximum estimates linear predictor (link) scale. subset method subsets species multicut object. plot method presents estimates species strata. lcplot method plots Lorenz curve single species 'multicut1' object. bestpart returns matrix best supported partitions species (samples rows, species columns). Binary partitions based Lorenz-tangent based optimal threshold (see lorenz). lorenz requires nonnegative fitted values guaranteed dist = \"gaussian\" identity link, see fix_fitted  ocoptions setting resolve (choosing different link function, distribution, centering modified variables advised). bestmodel returns best supported model manipulation (e.g. prediction). Note: custom distribution functions designed return point estimates, thus best model returned. case, use best partition returned bestpart refit model. getMLE returns named list corresponding best supported model. list following elements: coef Maximum Likelihood Estimate (MLE), vcov variance-covariance matrix MLE NULL, dist distribution inherited input object. fitted returns expected values predictor scale observations matrix (number observations number species). predict returns fitted values gnew xnew NULL, corresponding point predictions (expected values) predictor scale. coercion methods .data.frame return data frame.","code":""},{"path":"/reference/multicut.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Multi-level Response Model — multicut","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/multicut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multi-level Response Model — multicut","text":"","code":"## --- Gaussian ## simple example from Legendre 2013 ## Indicator Species: Computation, in ## Encyclopedia of Biodiversity, Volume 4 ## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5 gr <- as.factor(paste0(\"X\", rep(1:5, each=5))) spp <- cbind(Species1=rep(c(4,6,5,3,2), each=5),     Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),     Species3=rep(c(18,2,0,0,0), each=5)) rownames(spp) <- gr ## must add some noise to avoid perfect fit spp[6, \"Species1\"] <- 7 spp[1, \"Species3\"] <- 17 spp #>    Species1 Species2 Species3 #> X1        4        8       17 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X2        7        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X4        3        4        0 #> X4        3        4        0 #> X4        3        2        0 #> X4        3        0        0 #> X4        3        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0  ## negative expected values are not good oco <- ocoptions(fix_fitted=TRUE) summary(ocall <- multicut(spp ~ 1, strata=gr, dist=\"gaussian\")) #> Warning: Negative fitted values found for 2 species. #> Multivariate multticut results, dist = gaussian #>  #> Call: #> multicut.formula(formula = spp ~ 1, strata = gr, dist = \"gaussian\") #>  #> Species models with logLR >= 2: #>             split assoc      I logLR #> Species2 X1+X2+X3   +++ 0.9993 32.53 #> Species1    X2+X3   +++ 0.9705 52.87 #> Species3       X1   +++ 1.0000 91.55 #>  summary(multicut(spp, strata=gr, dist=\"gaussian\")) # alternative #> Warning: Negative fitted values found for 2 species. #> Multivariate multticut results, dist = gaussian #>  #> Call: #> multicut.default(Y = spp, strata = gr, dist = \"gaussian\") #>  #> Species models with logLR >= 2: #>             split assoc      I logLR #> Species2 X1+X2+X3   +++ 0.9993 32.53 #> Species1    X2+X3   +++ 0.9705 52.87 #> Species3       X1   +++ 1.0000 91.55 #>  ocoptions(oco) # reset options  ## --- Binomial ## simulated binary data set.seed(1234) n <- 200 x0 <- sample(1:4, n, TRUE) x1 <- ifelse(x0 <= 2, 1, 0) x2 <- rnorm(n, 0.5, 1) p1 <- plogis(-0.5 + 2*x1 + -0.8*x2) Y1 <- rbinom(n, 1, p1) p2 <- plogis(-0.1 + 2*ifelse(x0==4,1,0) + -0.8*x2) Y2 <- rbinom(n, 1, p2) p3 <- plogis(-0.1 + -0.8*x2) Y3 <- rbinom(n, 1, p3) Y <- cbind(SPP1=Y1, SPP2=Y2, SPP3=Y3) X <- model.matrix(~x2)  (m0 <- multicut1(Y1, X, as.factor(x0), dist=\"binomial\")) #> Univariate multicut results, dist = binomial #> logLR = 17.77 (logL_null = -132.3) #>  #> Expected values: #>      1      2      3      4  #> 0.7260 0.7771 0.4076 0.2789  #>  lcplot(m0)   summary(m1 <- multicut(Y ~ x2, strata=x0, dist=\"poisson\")) #> Multivariate multticut results, dist = poisson #>  #> Call: #> multicut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\") #>  #> Species models with logLR >= 2: #>      split assoc      I logLR #> SPP1   1+2   +++ 0.5048 8.894 #> SPP2     4    ++ 0.3644 5.902 #> 1 species not shown #>  plot(m1)   ## subset results summary(subset(m1, 1:2)) #> Multivariate multticut results, dist = poisson #>  #> Call: #> multicut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\") #>  #> Species models with logLR >= 2: #>      split assoc      I logLR #> SPP1   1+2   +++ 0.5048 8.894 #> SPP2     4    ++ 0.3644 5.902 #>   ## best partition head(bestpart(m1)) #>   SPP1 SPP2 SPP3 #> 4    0    1    1 #> 4    0    1    1 #> 2    1    0    0 #> 2    1    0    0 #> 1    1    0    1 #> 4    0    1    1  ## best model mods <- bestmodel(m1) mods #> $SPP1 #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #> `(Intercept)`             Z2             Z3             Z4             x2   #>      -0.32787        0.07209       -0.65520       -1.03924       -0.25016   #>  #> Degrees of Freedom: 200 Total (i.e. Null);  195 Residual #> Null Deviance:\t    212  #> Residual Deviance: 118.2 \tAIC: 316.2 #>  #> $SPP2 #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #> `(Intercept)`             Z2             Z3             Z4             x2   #>       -0.6518        -0.1977        -0.1922         0.5662        -0.3358   #>  #> Degrees of Freedom: 200 Total (i.e. Null);  195 Residual #> Null Deviance:\t    200  #> Residual Deviance: 115.9 \tAIC: 325.9 #>  #> $SPP3 #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #> `(Intercept)`             Z2             Z3             Z4             x2   #>      -0.85213       -0.31133       -0.03570        0.06478       -0.51151   #>  #> Degrees of Freedom: 200 Total (i.e. Null);  195 Residual #> Null Deviance:\t    266  #> Residual Deviance: 126.7 \tAIC: 270.7 #>  ## explore further confint(mods[[1]]) #> Waiting for profiling to be done... #>                    2.5 %      97.5 % #> `(Intercept)` -0.7365077  0.03360653 #> Z2            -0.4137503  0.57263652 #> Z3            -1.2951680 -0.04816757 #> Z4            -1.7561319 -0.38232824 #> x2            -0.4438465 -0.05168407  ## MLE and variance-covariance matrix (species 1) getMLE(m1, which = 1, vcov=TRUE) #> $coef #> `(Intercept)`            Z2            Z3            Z4            x2  #>   -0.32787491    0.07209324   -0.65519918   -1.03924068   -0.25016397  #>  #> $vcov #>               `(Intercept)`            Z2          Z3            Z4 #> `(Intercept)`   0.038311276 -3.706629e-02 -0.03722583 -0.0369859922 #> Z2             -0.037066290  6.267864e-02  0.03704133  0.0370358101 #> Z3             -0.037225827  3.704133e-02  0.09956289  0.0370294262 #> Z4             -0.036985992  3.703581e-02  0.03702943  0.1203610295 #> x2             -0.003575346  8.222807e-05  0.00052985 -0.0001430668 #>                          x2 #> `(Intercept)` -3.575346e-03 #> Z2             8.222807e-05 #> Z3             5.298500e-04 #> Z4            -1.430668e-04 #> x2             1.003152e-02 #>  #> $dist #> [1] \"poisson\" #>   ## fitted values head(fitted(m1)) #>        SPP1      SPP2      SPP3 #> 1 0.2027267 0.6752329 0.2850377 #> 2 0.2532343 0.9101916 0.4492035 #> 3 0.6720834 0.3536149 0.2338745 #> 4 0.7747911 0.4279878 0.3127995 #> 5 0.7816706 0.5813804 0.5038994 #> 6 0.2156772 0.7337562 0.3235123 ## prediction for new data head(predict(m1, gnew=x0, xnew=data.frame(x2=x2))) #>        SPP1      SPP2      SPP3 #> 1 0.2027267 0.6752329 0.2850377 #> 2 0.2532343 0.9101916 0.4492035 #> 3 0.6720834 0.3536149 0.2338745 #> 4 0.7747911 0.4279878 0.3127995 #> 5 0.7816706 0.5813804 0.5038994 #> 6 0.2156772 0.7337562 0.3235123  if (FALSE) { ## --- Zero-inflated Negative Binomial ## dolina example data(dolina) ## stratum as ordinal dolina$samp$stratum <- as.integer(dolina$samp$stratum) ## filter species to speed up things a bit Y <- dolina$xtab[,colSums(dolina$xtab > 0) >= 20] ## opticut results, note the cloglog link function dol <- multicut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zinb:cloglog\") summary(dol) ## vertical plot orientation plot(dol, horizontal=FALSE, pos=1, upper=0.8)  ## parallel library(parallel) cl <- makeCluster(2) multicut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zip\",cl=cl) stopCluster(cl)  ## --- Customizing distributions ## we may want to expand the Zero-inflation component in a ZIP model ## see how the return value needs to be structured fun <- function(Y, X, linkinv, zi_term, ...) {     X <- as.matrix(X)     mod <- pscl::zeroinfl(Y ~ X-1 | zi_term, dist = \"poisson\", ...)     list(coef=coef(mod),         logLik=logLik(mod),         linkinv=mod$linkinv) } Xdol <- model.matrix(~ stratum + lmoist + method, data=dolina$samp) ## this fits the null model (i.e. no partitions added) fun(Y[,\"amin\"], Xdol, zi_term=dolina$samp$method) ## now we can use dist=fun multicut1(Y[,\"amin\"], Xdol, Z=dolina$samp$mhab,     dist=fun, zi_term=dolina$samp$method) dol2 <- multicut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=fun, zi_term=dolina$samp$method) summary(dol2) }"},{"path":"/reference/occolors.html","id":null,"dir":"Reference","previous_headings":"","what":"Color Palettes for the opticut Package — occolors","title":"Color Palettes for the opticut Package — occolors","text":"convenient way setting color palettes opticut package.","code":""},{"path":"/reference/occolors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Color Palettes for the opticut Package — occolors","text":"","code":"occolors(theme) col2gray(col, method=\"BT.709\")"},{"path":"/reference/occolors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Color Palettes for the opticut Package — occolors","text":"theme character value, character vector, function used interpolate colors. built-values \"br\" (default, blue-red divergent palette, colorblind safe), \"gr\" (green-red divergent palette), \"bw\" (black white: grayscale converted \"br\" settings). See colorRampPalette, gray Examples. col vector color specification described help page col2rgb function. converted grayscale. method character, method used grayscale conversion. See Details.","code":""},{"path":"/reference/occolors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Color Palettes for the opticut Package — occolors","text":"Grayscale conversion methods col2gray calculate gray levels based red (R), green (G), blue (B) color channels follows: \"BT.709\" 0.2126 * R + 0.7152 * G + 0.0722 * B,     luminosity correction following  ITU-R BT.709 recommendation; \"BT.601\" 0.299 * R + 0.587 * G + 0.114 * B,     luminosity correction following  ITU-R BT.601 recommendation; \"desaturate\" (max(R, G, B) + min(R, G, B)) / 2,     also called lightness; \"average\" (R + G + B) / 3; \"maximum\" max(R, G, B); \"minimum\" min(R, G, B); \"red\" R; \"green\" G; \"blue\" B.","code":""},{"path":"/reference/occolors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Color Palettes for the opticut Package — occolors","text":"occolors returns function, see colorRampPalette. col2gray returns vector gray colors based conversion method gray.","code":""},{"path":"/reference/occolors.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Color Palettes for the opticut Package — occolors","text":"Peter Solymos <psolymos@gmail.com> Hexadecimal values built-palettes taken https://colorbrewer2.org/. Converting color grayscale: https://en.wikipedia.org/wiki/Grayscale","code":""},{"path":[]},{"path":"/reference/occolors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Color Palettes for the opticut Package — occolors","text":"","code":"## using palettes plot(1:100, rep(2, 100), pch = 15,     ylim = c(0, 21), axes = FALSE, ann = FALSE,     col = occolors()(100)) # default 'bg' text(50, 1, \"theme = 'br'\") points(1:100, rep(5, 100), pch = 15,     col=occolors(\"gr\")(100)) text(50, 4, \"theme = 'gr'\") points(1:100, rep(8, 100), pch = 15,     col=occolors(\"bw\")(100)) text(50, 7, \"theme = 'bw'\") points(1:100, rep(11, 100), pch = 15,     col=occolors(terrain.colors)(100)) text(50, 10, \"theme = terrain.colors\") points(1:100, rep(14, 100), pch = 15,     col=occolors(c(\"purple\", \"pink\", \"orange\"))(100)) text(50, 13, \"theme = c('purple', 'pink', 'orange')\") points(1:100, rep(17, 100), pch = 15,     col=occolors(c(\"#a6611a\", \"#ffffbf\", \"#018571\"))(100)) text(50, 16, \"theme = c('#a6611a', '#ffffbf', '#018571')\") points(1:100, rep(20, 100), pch = 15,     col=occolors(c(\"#7b3294\", \"#ffffbf\", \"#008837\"))(100)) text(50, 19, \"theme = c('#7b3294', '#ffffbf', '#008837')\")   ## grayscale conversions n <- 25 col <- occolors(\"br\")(n) method <- c(\"BT.709\", \"BT.601\",     \"desaturate\", \"average\", \"maximum\", \"minimum\",     \"red\", \"green\", \"blue\") plot(0, type=\"n\", ann=FALSE, axes=FALSE,     xlim=c(0, n), ylim=c(3*length(method), 0)) for (j in 1:length(method)) {     for (i in 1:n) {         polygon(c(i-1, i, i, i-1), c(0, 0, 1, 1)+((j-1)*3),             col=col[i], border=col[i])         polygon(c(i-1, i, i, i-1), c(1, 1, 2, 2)+((j-1)*3),             col=col2gray(col[i], method=method[j]),             border=col2gray(col[i], method=method[j]))         text(n/2, 1+((j-1)*3), method[j])     } }"},{"path":"/reference/ocoptions.html","id":null,"dir":"Reference","previous_headings":"","what":"Options for the opticut Package — ocoptions","title":"Options for the opticut Package — ocoptions","text":"convenient way handling options related opticut package.","code":""},{"path":"/reference/ocoptions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Options for the opticut Package — ocoptions","text":"","code":"ocoptions(...)"},{"path":"/reference/ocoptions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Options for the opticut Package — ocoptions","text":"... arguments tag = value form, list tagged values. tags must come parameters described .","code":""},{"path":"/reference/ocoptions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Options for the opticut Package — ocoptions","text":"parameters set ocoptions, former values returned invisible named list. list can passed argument ocoptions restore parameter values. Tags following: collapse character value used merging factor levels,   default \"+\". cut log likelihood ratio value, model/species lower   values excluded summaries plots,   default 2. sort logical value indicating species/partitions   meaningfully sorted, default TRUE.   can take numeric value species (1)   partitions (2) sorted (1:2 equivalent   TRUE). theme color theme used based occolors,   default \"br\". check_comb check design matrices complementary partitions   using checkComb,   default TRUE. try_error opticut multicut   try exclude   species models failed (TRUE), default   stop error encountered (FALSE). scale scaling factor used calculate indicator potential ()   based estimated contrast (x): = abs(tanh(x*scale)),   default 0.5. fix_fitted bestpart.multicut   uses lorenz requires nonnegative fitted values,   however models identity link can lead negative expected values.   TRUE fitted values (x) adjusted x' = x + abs(min(x))   ensure nonnegativity. default FALSE. robust_loglik ill-defined models resulting perfect fit   (infinite log likelihood, NA, NaN)   allowed. default TRUE makes ill-defined   log likelihoods small real number   -(.Machine$double.xmax^(1/3)).   FALSE equivalent allowing every model   safeguard cases .","code":""},{"path":"/reference/ocoptions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Options for the opticut Package — ocoptions","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":"/reference/ocoptions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options for the opticut Package — ocoptions","text":"","code":"## simple example from Legendre 2013 ## Indicator Species: Computation, in ## Encyclopedia of Biodiversity, Volume 4 ## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5 gr <- as.factor(paste0(\"X\", rep(1:5, each=5))) spp <- cbind(Species1=rep(c(4,6,5,3,2), each=5),     Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),     Species3=rep(c(18,2,0,0,0), each=5)) rownames(spp) <- gr ## must add some noise to avoid perfect fit spp[6, \"Species1\"] <- 7 spp[1, \"Species3\"] <- 17 spp #>    Species1 Species2 Species3 #> X1        4        8       17 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X2        7        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X4        3        4        0 #> X4        3        4        0 #> X4        3        2        0 #> X4        3        0        0 #> X4        3        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0  ## current settings print(unlist(ocoptions())) # these give identical answers #>      collapse           cut          sort         theme    check_comb  #>           \"+\"           \"2\"        \"TRUE\"          \"br\"        \"TRUE\"  #>     try_error         scale    fix_fitted robust_loglik  #>       \"FALSE\"         \"0.5\"       \"FALSE\"        \"TRUE\"  unlist(getOption(\"ocoptions\")) #>      collapse           cut          sort         theme    check_comb  #>           \"+\"           \"2\"        \"TRUE\"          \"br\"        \"TRUE\"  #>     try_error         scale    fix_fitted robust_loglik  #>       \"FALSE\"         \"0.5\"       \"FALSE\"        \"TRUE\"  summary(ocall <- opticut(spp ~ 1, strata=gr, dist=\"gaussian\", comb=\"all\")) #> Multivariate opticut results, comb = all, dist = gaussian #>  #> Call: #> opticut.formula(formula = spp ~ 1, strata = gr, dist = \"gaussian\",  #>     comb = \"all\") #>  #> Best supported models with logLR >= 2: #>          split assoc      I mu0  mu1 logLR      w #> Species2 X1+X3   +++ 0.9866 2.0  7.0 14.82 0.4995 #> Species1 X2+X3   +++ 0.8617 3.0  5.6 16.74 0.7035 #> Species3    X1   +++ 1.0000 0.5 17.8 54.26 1.0000 #> 15 binary splits #>   ## resetting pboptions and checking new settings ocop <- ocoptions(collapse=\"&\", sort=FALSE) unlist(getOption(\"ocoptions\")) #>      collapse           cut          sort         theme    check_comb  #>           \"&\"           \"2\"       \"FALSE\"          \"br\"        \"TRUE\"  #>     try_error         scale    fix_fitted robust_loglik  #>       \"FALSE\"         \"0.5\"       \"FALSE\"        \"TRUE\"  ## running again with new settings summary(ocall <- opticut(spp ~ 1, strata=gr, dist=\"gaussian\", comb=\"all\")) #> Multivariate opticut results, comb = all, dist = gaussian #>  #> Call: #> opticut.formula(formula = spp ~ 1, strata = gr, dist = \"gaussian\",  #>     comb = \"all\") #>  #> Best supported models with logLR >= 2: #>          split assoc      I mu0  mu1 logLR      w #> Species1 X2&X3   +++ 0.8617 3.0  5.6 16.74 0.7035 #> Species2 X1&X3   +++ 0.9866 2.0  7.0 14.82 0.4995 #> Species3    X1   +++ 1.0000 0.5 17.8 54.26 1.0000 #> 15 binary splits #>   ## resetting original ocoptions(ocop) unlist(getOption(\"ocoptions\")) #>      collapse           cut          sort         theme    check_comb  #>           \"+\"           \"2\"        \"TRUE\"          \"br\"        \"TRUE\"  #>     try_error         scale    fix_fitted robust_loglik  #>       \"FALSE\"         \"0.5\"       \"FALSE\"        \"TRUE\""},{"path":"/reference/opticut-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood Based Optimal Partitioning and Indicator Species Analysis — opticut-package","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis — opticut-package","text":"Likelihood based optimal partitioning indicator   species analysis. Finding best binary partition species   based model selection, possibility take account   modifying/confounding variables described   Kemencei et al. (2014) <doi:10.1556/ComEc.15.2014.2.6>.   package implements binary multi-level response models,   various measures uncertainty, Lorenz-curve based thresholding,   native support parallel computations.","code":""},{"path":"/reference/opticut-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis — opticut-package","text":"DESCRIPTION file: package yet installed build time.   Index:  package yet installed build time. main user interface opticut multicut functions find optimal binary multi-level response models. Make sure evaluate uncertainty. optilevels finds optimal number factor levels.","code":""},{"path":"/reference/opticut-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis — opticut-package","text":"Peter Solymos [cre, aut] (<https://orcid.org/0000-0001-7337-1740>), Ermias T. Azeria [ctb] Maintainer: Peter Solymos <psolymos@gmail.com>","code":""},{"path":"/reference/opticut-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis — opticut-package","text":"Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, ., Hornung, E. & Solymos, P., 2014. Microhabitat associations land snails forested dolinas: implications coarse filter conservation. Community Ecology 15:180--186. <doi:10.1556/ComEc.15.2014.2.6>","code":""},{"path":"/reference/opticut-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood Based Optimal Partitioning and Indicator Species Analysis — opticut-package","text":"","code":"## community data y <- cbind(     Sp1=c(4,6,3,5, 5,6,3,4, 4,1,3,2),     Sp2=c(0,0,0,0, 1,0,0,1, 4,2,3,4),     Sp3=c(0,0,3,0, 2,3,0,5, 5,6,3,4))  ## stratification g <-    c(1,1,1,1, 2,2,2,2, 3,3,3,3)  ## find optimal partitions for each species oc <- opticut(formula = y ~ 1, strata = g, dist = \"poisson\") summary(oc) #> Multivariate opticut results, comb = rank, dist = poisson #>  #> Call: #> opticut.formula(formula = y ~ 1, strata = g, dist = \"poisson\") #>  #> Best supported models with logLR >= 2: #>     split assoc      I  mu0  mu1 logLR      w #> Sp3   2+3    ++ 0.6471 0.75 3.50 4.793 0.6962 #> Sp2     3   +++ 0.8571 0.25 3.25 9.203 0.9577 #> 2 binary splits #> 1 species not shown #>   ## visualize the results plot(oc, cut = -Inf)   ## quantify uncertainty uc <- uncertainty(oc, type = \"asymp\", B = 999) summary(uc) #> Multivariate multicut uncertainty results #> type = asymp, B = 999, level = 0.95 #>  #>     split R      I   Lower  Upper #> Sp1   1+2 1 0.2839 0.01915 0.5529 #> Sp3   2+3 1 0.6136 0.22377 0.8693 #> Sp2     3 1 0.8270 0.50338 0.9663  ## go beyond binary partitions  mc <- multicut(formula = y ~ 1, strata = g, dist = \"poisson\") summary(mc) #> Multivariate multticut results, dist = poisson #>  #> Call: #> multicut.formula(formula = y ~ 1, strata = g, dist = \"poisson\") #>  #> Species models with logLR >= 2: #>     split assoc      I  logLR #> Sp2     3   +++ 1.0000 10.589 #> Sp3     3    ++ 0.7143  5.952 #> 1 species not shown #>   ol <- optilevels(y[,\"Sp2\"], as.factor(g)) ol[c(\"delta\", \"coef\", \"rank\", \"levels\")] #> $delta #> [1]  0.0000000 -0.4980423         NA #>  #> $coef #>         1    2    3 #> [1,] 0.00 0.50 3.25 #> [2,] 0.25 0.25 3.25 #> [3,]   NA   NA   NA #>  #> $rank #>       1  2  3 #> [1,]  1  2  3 #> [2,]  1  1  2 #> [3,] NA NA NA #>  #> $levels #> $levels[[1]] #>   1   2   3  #> \"1\" \"2\" \"3\"  #>  #> $levels[[2]] #>     1     2     3  #> \"1+2\" \"1+2\"   \"3\"  #>  #>"},{"path":"/reference/opticut.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Binary Response Model — opticut","title":"Optimal Binary Response Model — opticut","text":"functions fits multi-level response model species finding best binary partition based model selection. Possibly controlling modifying/confounding variables. general algorithm described Kemencei et al. 2014.","code":""},{"path":"/reference/opticut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal Binary Response Model — opticut","text":"","code":"opticut1(Y, X, Z, dist = \"gaussian\", sset=NULL, ...)  opticut(...) # S3 method for default opticut(Y, X, strata, dist = \"gaussian\",     comb = c(\"rank\", \"all\"), sset=NULL, cl = NULL, ...) # S3 method for formula opticut(formula, data, strata, dist = \"gaussian\",     comb = c(\"rank\", \"all\"), sset=NULL, cl = NULL, ...)  fix_levels(x, sep = \"_\") strata(object, ...) # S3 method for opticut strata(object, ...)  # S3 method for opticut bestmodel(object, which = NULL, ...) # S3 method for opticut bestpart(object, pos_only = FALSE, ...) # S3 method for opticut getMLE(object, which, vcov=FALSE, ...) # S3 method for opticut subset(x, subset=NULL, ...) # S3 method for opticut fitted(object, ...) # S3 method for opticut predict(object, gnew=NULL, xnew=NULL, ...)  wplot(x, ...) # S3 method for opticut1 wplot(x, cut, ylim = c(-1, 1),     las=1, ylab = \"Model weight * Association\", xlab = \"Partitions\",     theme, mar = c(5, 4, 4, 4) + 0.1, bty = \"o\", ...) # S3 method for opticut wplot(x, which = NULL, cut, sort,     las = 1, ylab = \"Model weight * Association\", xlab = \"Partitions\",     theme, mar = c(5, 4, 4, 4) + 0.1, bty = \"o\", ...) # S3 method for opticut plot(x, which = NULL, cut, sort,     las, ylab = \"Relative abundance\", xlab = \"Strata\",     show_I = TRUE, show_S = TRUE, hr = TRUE, tick = TRUE,     theme, mar = c(5, 4, 4, 4) + 0.1, bty = \"o\",     lower = 0, upper = 1, pos = 0, horizontal=TRUE, ...)  # S3 method for opticut1 print(x, cut, sort, digits, ...) # S3 method for opticut print(x, digits, ...) # S3 method for summary.opticut print(x, cut, sort, digits, ...) # S3 method for opticut summary(object, ...)  # S3 method for opticut as.data.frame(x,     row.names = NULL, optional = FALSE, cut, sort, ...) # S3 method for summary.opticut as.data.frame(x,     row.names = NULL, optional = FALSE, cut, sort, ...)"},{"path":"/reference/opticut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Binary Response Model — opticut","text":"formula two sided model formula, response species data (matrix, possible vector single species case) left-hand side, model terms modifying effects right-hand side (structure depending underlying functions). example, basic Gaussian case can y ~ 1 (modifying variables) y ~ x (modifying variables). Centering modifying terms (choosing origin wisely) generally recommended (especially Gaussian distribution linear predictors additive response scale) relative abundance contrast estimated origin (0). data optional data frame, list environment containing variables model. found data, variables taken parent.frame(), typically environment opticut called. strata vector (usually factor), unique values define partitions (must least 2 unique levels, empty levels dropped). can also matrix rows observations binary partitions columns. dist character function, distribution fit. character, can follow one patterns: \"family\", \"family:link\" appropriate (link argument underlying function, link can specified via family argument). See Details Examples. comb character, define binary partitions. \"rank\" uses rankComb, \"\" uses allComb. sset optional vector specifying subset observations (rows) used fitting process. NULL means subset taken. cl cluster object, integer multiple cores parallel computations (integer value forking ignored Windows). Y numeric vector observations opticut1, vector community matrix opticut.default. X numeric, design matrix. Can missing, case intercept-model assumed. Z factor (must least 2 unique levels, triggers rankComb), design matrix (custom matrix returned allComb. x, object object plot, print, summarize. fix_levels needs factor. cut log likelihood ratio value used cut-showing species whose log likelihood ratio less cut-. sort logical value indicating species/partitions meaningfully sorted, default TRUE. can take numeric value species (1) partitions (2) sorted (1:2 equivalent TRUE). show_I logical, indicator potential () shown. show_S logical, number indicator species shown. hr, tick logical, horizontal rules (hr) ticks axis legends (tick) added. Default TRUE . theme color theme defined occolors. mar numeric, graphical parameters plot margin par. ylab, xlab, las, ylim graphical arguments, see plot. default, las 1 horizontal = TRUE 2 horizontal = FALSE. bty Character, determines type box drawn around plots, see par. lower, upper numeric (0 1), lower minimum upper maximum height rectangles drawn plot. need [0, 1] higher smaller lower. pos numeric, position rectangles plot relative baseline. Value must [-1, 1] range (vs. baseline). horizontal logical, plot orientation: species rows (TRUE) columns (FALSE). digits numeric, number significant digits output. numeric character (can vector) defining subset species fitted object, NULL (species, default). sep character string separate sub-strings factor levels. row.names NULL character vector giving row names data frame. Missing values allowed. See .data.frame. optional logical. TRUE, setting row names converting column names (syntactic names: see make.names) optional. See .data.frame. pos_only logical, best partition normally returns original variable without recognizing direction association. pos_only = TRUE returns values negative associations taken account 1 indicates strata positive association. important comb \"rank\". subset logical, numeric, character index indicating species keep, missing values accepted. default NULL returns original object without subsetting. vcov logical, variance-covariance matrix returned. gnew, xnew new values strata modifiers (right-hand-side formula) predict , NULL. Predicting new strata available comb = \"rank\" models . ... arguments passed underlying functions.","code":""},{"path":"/reference/opticut.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimal Binary Response Model — opticut","text":"Currently available distributions: \"gaussian\" real valued continuous observations, e.g. biomass, uses lm stats package. Identity link assumed. Centering modified variables generally advised avoid negative expected values response nonnegative. \"poisson\" Poisson count data, uses glm stats package. Exponential (log) link assumed. \"binomial\" presence-absence (detection-nondetection) type data, uses glm stats package. Logistic (logit) link assumed. \"negbin\" overdispersed Negative Binomial count data, uses glm.nb MASS package. Exponential (log) link assumed. \"beta\" continuous response unit interval (0-1), e.g. percent cover, uses betareg betareg package. Logistic (logit) link mean model assumed. \"zip\" zero-inflated Poisson counts, indicative properties tested part abundance model, uses zeroinfl pscl package. Exponential (log) link used count based analysis, second part dist argument following colon used link function zero component (logistic link assumed). \"zinb\" zero-inflated Negative Binomial counts, indicative properties tested part abundance model, uses zeroinfl pscl package. zero-inflation component refers probability 0. Exponential (log) link used count based analysis, second part dist argument following colon used link function zero component (logistic link assumed). \"zip2\" zero-inflated Poisson counts, indicative properties tested part zero-model, uses zeroinfl pscl package. zero-inflation component refers probability 1 consistent methods regarding positive negative effects. Logistic (logit) link assumed zero-nonzero based analysis, symmetric link functions (logit, probit) allowed. Exponential (log) link used count data part changed. \"zinb2\" zero-inflated Negative Binomial counts, indicative properties tested part zero-model, uses zeroinfl pscl package. zero-inflation component refers probability 1 consistent methods regarding positive negative effects. Logistic (logit) link assumed zero-nonzero based analysis, symmetric link functions (logit, probit) allowed. Exponential (log) link used count data part changed. \"rsf\" presence-data using resource selection functions (RSF) explained  rsf ResourceSelection package, assuming global availability (m = 0). \"rsf\" works single species using opticut1 'presence-' type data kept single matrix-like object multiple species. Intercept model (.e. modifier variables right-hand-side formula) accepted \"rsf\". Exponential (log) link assumed. \"rspf\" presence-data using resource selection probability functions (RSPF) explained rspf ResourceSelection package, assuming global availability (m = 0). \"rspf\" works single species using opticut1 'presence-' type data kept single matrix-like object multiple species. Intercept model accepted \"rspf\", need least one continuous modifier variable identifiability (see Solymos & Lele 2016). Logistic (logit) link assumed. Custom distributions can defined, see Examples. Note: downstream algorithms methods work custom distributions. fix_levels utility function replacing characters factor levels identical value getOption(\"ocoptions\")$collapse value. case can lead error specifying strata argument, fix_levels can help.","code":""},{"path":"/reference/opticut.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Optimal Binary Response Model — opticut","text":"use opticut1 function generally discouraged: internal checks guaranteed flag issues formula--model-matrix translation side-stepped (happening modifier variables supplied X argument opticut1). Use opticut single species instead.","code":""},{"path":"/reference/opticut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal Binary Response Model — opticut","text":"opticut1 returns object class opticut1, modified data frame additional attributes. opticut returns object class opticut, list following components: \"call\" function call. \"species\" list species specific opticut1 objects. \"X\" modifying variables model matrix. \"Y\" response, single species vector matrix. \"strata\" defines partitions. \"nobs\" sample size. \"sset\" subset, specified. \"nsplit\" number binary splits considered. \"dist\" distribution. \"comb\" combination type. \"failed\" IDs failed species models dropped results list. \"collapse\" character used combining partition labels. fix_levels returns factor modified levels. strata method extracts strata argument factor. method finds unique row combinations custom matrix supplied strata. print summary methods called side effects. summary shows following information: best supported split, strength sign association, indicator potential (), expected values (mu0, mu1), log likelihood ratio (logLR), model weights(w). subset method subsets species opticut object. plot method presents contrasts species strata. wplot (weight plot) shows model weights partitions. bestpart returns matrix best supported partitions species (samples rows, species columns). bestmodel returns best supported model manipulation (e.g. prediction). Note: custom distribution functions designed return point estimates, thus best model returned. case, use best partition returned bestpart refit model. getMLE returns named list corresponding best supported model. list following elements: coef Maximum Likelihood Estimate (MLE), vcov variance-covariance matrix MLE NULL, dist distribution inherited input object. fitted returns expected values predictor scale observations matrix (number observations number species). predict returns fitted values gnew xnew NULL, corresponding point predictions (expected values) predictor scale (available comb = \"rank\" models ). coercion methods .data.frame return data frame.","code":""},{"path":"/reference/opticut.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Optimal Binary Response Model — opticut","text":"Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, ., Hornung, E. & Solymos, P. (2014): Microhabitat associations land snails forested dolinas: implications coarse filter conservation. Community Ecology 15:180--186. <doi:10.1556/ComEc.15.2014.2.6> Solymos, P. & Lele, S. R. (2016): Revisiting resource selection probability functions single-visit methods: clarification extensions. Methods Ecology Evolution 7:196--205. <doi:10.1111/2041-210X.12432>","code":""},{"path":"/reference/opticut.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Optimal Binary Response Model — opticut","text":"Peter Solymos <psolymos@gmail.com> Ermias T. Azeria","code":""},{"path":[]},{"path":"/reference/opticut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Binary Response Model — opticut","text":"","code":"## --- Gaussian ## simple example from Legendre 2013 ## Indicator Species: Computation, in ## Encyclopedia of Biodiversity, Volume 4 ## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5 gr <- as.factor(paste0(\"X\", rep(1:5, each=5))) spp <- cbind(Species1=rep(c(4,6,5,3,2), each=5),     Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),     Species3=rep(c(18,2,0,0,0), each=5)) rownames(spp) <- gr ## must add some noise to avoid perfect fit spp[6, \"Species1\"] <- 7 spp[1, \"Species3\"] <- 17 spp #>    Species1 Species2 Species3 #> X1        4        8       17 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X2        7        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X4        3        4        0 #> X4        3        4        0 #> X4        3        2        0 #> X4        3        0        0 #> X4        3        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0  ## all partitions summary(ocall <- opticut(spp ~ 1, strata=gr, dist=\"gaussian\", comb=\"all\")) #> Multivariate opticut results, comb = all, dist = gaussian #>  #> Call: #> opticut.formula(formula = spp ~ 1, strata = gr, dist = \"gaussian\",  #>     comb = \"all\") #>  #> Best supported models with logLR >= 2: #>          split assoc      I mu0  mu1 logLR      w #> Species2 X1+X3   +++ 0.9866 2.0  7.0 14.82 0.4995 #> Species1 X2+X3   +++ 0.8617 3.0  5.6 16.74 0.7035 #> Species3    X1   +++ 1.0000 0.5 17.8 54.26 1.0000 #> 15 binary splits #>  summary(opticut(spp, strata=gr, dist=\"gaussian\", comb=\"all\")) # alternative #> Multivariate opticut results, comb = all, dist = gaussian #>  #> Call: #> opticut.default(Y = spp, strata = gr, dist = \"gaussian\", comb = \"all\") #>  #> Best supported models with logLR >= 2: #>          split assoc      I mu0  mu1 logLR      w #> Species2 X1+X3   +++ 0.9866 2.0  7.0 14.82 0.4995 #> Species1 X2+X3   +++ 0.8617 3.0  5.6 16.74 0.7035 #> Species3    X1   +++ 1.0000 0.5 17.8 54.26 1.0000 #> 15 binary splits #>   ## rank based partitions summary(ocrank <- opticut(spp ~ 1, strata=gr, dist=\"gaussian\", comb=\"rank\")) #> Multivariate opticut results, comb = rank, dist = gaussian #>  #> Call: #> opticut.formula(formula = spp ~ 1, strata = gr, dist = \"gaussian\",  #>     comb = \"rank\") #>  #> Best supported models with logLR >= 2: #>          split assoc      I mu0  mu1 logLR      w #> Species2 X1+X3   +++ 0.9866 2.0  7.0 14.82 0.4996 #> Species1 X2+X3   +++ 0.8617 3.0  5.6 16.74 0.7036 #> Species3    X1   +++ 1.0000 0.5 17.8 54.26 1.0000 #> 4 binary splits #>  summary(opticut(spp, strata=gr, dist=\"gaussian\", comb=\"rank\")) # alternative #> Multivariate opticut results, comb = rank, dist = gaussian #>  #> Call: #> opticut.default(Y = spp, strata = gr, dist = \"gaussian\", comb = \"rank\") #>  #> Best supported models with logLR >= 2: #>          split assoc      I mu0  mu1 logLR      w #> Species2 X1+X3   +++ 0.9866 2.0  7.0 14.82 0.4996 #> Species1 X2+X3   +++ 0.8617 3.0  5.6 16.74 0.7036 #> Species3    X1   +++ 1.0000 0.5 17.8 54.26 1.0000 #> 4 binary splits #>   ## --- Binomial ## simulated binary data set.seed(1234) n <- 200 x0 <- sample(1:4, n, TRUE) x1 <- ifelse(x0 <= 2, 1, 0) x2 <- rnorm(n, 0.5, 1) p1 <- plogis(-0.5 + 2*x1 + -0.8*x2) Y1 <- rbinom(n, 1, p1) p2 <- plogis(-0.1 + 2*ifelse(x0==4,1,0) + -0.8*x2) Y2 <- rbinom(n, 1, p2) p3 <- plogis(-0.1 + -0.8*x2) Y3 <- rbinom(n, 1, p3) Y <- cbind(SPP1=Y1, SPP2=Y2, SPP3=Y3) X <- model.matrix(~x2)  ## all partitions, single species Z <- allComb(x0) opticut1(Y1, X, Z, dist=\"binomial\") #> Univariate opticut results, comb = all, dist = binomial #> I = 0.7139; w = 0.9989; H = 0.9978; logL_null = -132.3 #>  #> Best supported models with logLR >= 2: #>     assoc      I    mu0    mu1  logLR         w #> 1+2   +++ 0.7139 0.3389 0.7544 16.807 9.989e-01 #> 4     --- 0.6557 0.6465 0.2755  9.764 8.724e-04 #> 2     +++ 0.5952 0.4594 0.7700  8.336 2.091e-04 #> 1      ++ 0.4260 0.4986 0.7118  3.165 1.188e-06 #> 3      -- 0.3744 0.5914 0.3972  2.500 6.111e-07 #> 7 binary splits (2 models not shown) #>   ## rank based partitions, single species opticut1(Y1, X, as.factor(x0), dist=\"binomial\") #> Univariate opticut results, comb = rank, dist = binomial #> I = 0.7139; w = 0.9989; H = 0.9978; logL_null = -132.3 #>  #> Best supported models with logLR >= 2: #>       assoc      I    mu0    mu1  logLR         w #> 1+2     +++ 0.7139 0.3389 0.7544 16.807 0.9989185 #> 1+2+3   +++ 0.6557 0.2755 0.6465  9.764 0.0008724 #> 2       +++ 0.5952 0.4594 0.7700  8.336 0.0002091 #> 3 binary splits  #>   ## all partitions, multiple species (m1 <- opticut(Y ~ x2, strata=x0, dist=\"poisson\", comb=\"all\")) #> Multivariate opticut results, comb = all, dist = poisson #>  #> Call: #> opticut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\",  #>     comb = \"all\") #>  #> 3 species, 7 binary splits #>  summary(m1) #> Multivariate opticut results, comb = all, dist = poisson #>  #> Call: #> opticut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\",  #>     comb = \"all\") #>  #> Best supported models with logLR >= 2: #>      split assoc      I    mu0    mu1 logLR      w #> SPP1   1+2   +++ 0.4137 0.3118 0.7518 8.340 0.9438 #> SPP2     4    ++ 0.3370 0.4550 0.9175 5.664 0.8333 #> 7 binary splits #> 1 species not shown #>  ## show all species summary(m1, cut=0) #> Multivariate opticut results, comb = all, dist = poisson #>  #> Call: #> opticut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\",  #>     comb = \"all\") #>  #> Best supported models with logLR >= 2: #>      split assoc      I    mu0    mu1 logLR      w #> SPP1   1+2   +++ 0.4137 0.3118 0.7518 8.340 0.9438 #> SPP2     4    ++ 0.3370 0.4550 0.9175 5.664 0.8333 #> 7 binary splits #> 1 species not shown #>  ## plot best partitions and indicator values plot(m1)  ## model weights for all species wplot(m1)  ## different ways of plotting weights for single species wplot(m1$species[[1]]) wplot(m1, which = 1)   ## rank based partitions, multiple species summary(m2 <- opticut(Y ~ x2, strata=x0, dist=\"poisson\", comb=\"rank\")) #> Multivariate opticut results, comb = rank, dist = poisson #>  #> Call: #> opticut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\",  #>     comb = \"rank\") #>  #> Best supported models with logLR >= 2: #>      split assoc      I    mu0    mu1 logLR      w #> SPP1   1+2   +++ 0.4137 0.3118 0.7518 8.340 0.9462 #> SPP2     4    ++ 0.3370 0.4550 0.9175 5.664 0.8687 #> 3 binary splits #> 1 species not shown #>  ## subset results summary(subset(m2, 1:2)) #> Multivariate opticut results, comb = rank, dist = poisson #>  #> Call: #> opticut.formula(formula = Y ~ x2, strata = x0, dist = \"poisson\",  #>     comb = \"rank\") #>  #> Best supported models with logLR >= 2: #>      split assoc      I    mu0    mu1 logLR      w #> SPP1   1+2   +++ 0.4137 0.3118 0.7518 8.340 0.9462 #> SPP2     4    ++ 0.3370 0.4550 0.9175 5.664 0.8687 #> 3 binary splits #>   ## best partition head(bestpart(m2)) #>   SPP1 SPP2 SPP3 #> 4    0    1    1 #> 4    0    1    1 #> 2    1    0    0 #> 2    1    0    0 #> 1    1    0    1 #> 4    0    1    1  ## best model mods <- bestmodel(m2) mods #> $SPP1 #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #> `(Intercept)`             Z1             x2   #>       -1.1653         0.8801        -0.2521   #>  #> Degrees of Freedom: 200 Total (i.e. Null);  197 Residual #> Null Deviance:\t    212  #> Residual Deviance: 119.3 \tAIC: 313.3 #>  #> $SPP2 #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #> `(Intercept)`             Z1             x2   #>       -0.7875         0.7014        -0.3343   #>  #> Degrees of Freedom: 200 Total (i.e. Null);  197 Residual #> Null Deviance:\t    200  #> Residual Deviance: 116.4 \tAIC: 322.4 #>  #> $SPP3 #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #> `(Intercept)`             Z1             x2   #>       -1.1635         0.3235        -0.5092   #>  #> Degrees of Freedom: 200 Total (i.e. Null);  197 Residual #> Null Deviance:\t    266  #> Residual Deviance: 126.8 \tAIC: 266.8 #>  ## explore further confint(mods[[1]]) #> Waiting for profiling to be done... #>                    2.5 %      97.5 % #> `(Intercept)` -1.5658931 -0.81050022 #> Z1             0.4493567  1.33725540 #> x2            -0.4472278 -0.05197309  ## MLE and variance-covariance matrix (species 1) getMLE(m2, which=1, vcov=TRUE) #> $coef #> `(Intercept)`            Z1            x2  #>    -1.1652948     0.8800652    -0.2520902  #>  #> $vcov #>               `(Intercept)`            Z1            x2 #> `(Intercept)`   0.036867825 -0.0356672658 -0.0034330887 #> Z1             -0.035667266  0.0508649662 -0.0001321465 #> x2             -0.003433089 -0.0001321465  0.0101950604 #>  #> $dist #> [1] \"poisson\" #>   ## fitted values head(fitted(m2)) #>        SPP1      SPP2      SPP3 #> 1 0.2476256 0.6758558 0.2709819 #> 2 0.3098497 0.9098139 0.4261917 #> 3 0.6518694 0.3765488 0.2341692 #> 4 0.7523114 0.4553558 0.3127900 #> 5 0.8162386 0.5073633 0.5096759 #> 6 0.2635700 0.7341598 0.3073866 ## prediction for new data head(predict(m2, gnew=x0, xnew=data.frame(x2=x2))) #>        SPP1      SPP2      SPP3 #> 1 0.2476256 0.6758558 0.2709819 #> 2 0.3098497 0.9098139 0.4261917 #> 3 0.6518694 0.3765488 0.2341692 #> 4 0.7523114 0.4553558 0.3127900 #> 5 0.8162386 0.5073633 0.5096759 #> 6 0.2635700 0.7341598 0.3073866  if (FALSE) { ## --- Zero-inflated Negative Binomial ## dolina example data(dolina) ## stratum as ordinal dolina$samp$stratum <- as.integer(dolina$samp$stratum) ## filter species to speed up things a bit Y <- dolina$xtab[,colSums(dolina$xtab > 0) >= 20] ## opticut results, note the cloglog link function dol <- opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zinb:cloglog\") summary(dol) ## vertical plot orientation plot(dol, horizontal=FALSE, pos=1, upper=0.8)  ## parallel computing comparisons library(parallel) cl <- makeCluster(2) ## sequential, all combinations (2^(K-1) - 1) system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zinb\", comb=\"all\", cl=NULL)) ## sequential, rank based combinations (K - 1) system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zinb\", comb=\"rank\", cl=NULL)) ## parallel, all combinations (2^(K-1) - 1) system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zinb\", comb=\"all\", cl=cl)) ## parallel, rank based combinations (K - 1) system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"zinb\", comb=\"rank\", cl=cl)) stopCluster(cl)  ## --- Customizing distributions ## we may want to expand the Zero-inflation component in a ZIP model ## see how the return value needs to be structured fun <- function(Y, X, linkinv, zi_term, ...) {     X <- as.matrix(X)     mod <- pscl::zeroinfl(Y ~ X-1 | zi_term, dist = \"poisson\", ...)     list(coef=coef(mod),         logLik=logLik(mod),         linkinv=mod$linkinv) } Xdol <- model.matrix(~ stratum + lmoist + method, data=dolina$samp) ## this fits the null model (i.e. no partitions added) fun(Y[,\"amin\"], Xdol, zi_term=dolina$samp$method) ## now we can use dist=fun opticut1(Y[,\"amin\"], Xdol, Z=dolina$samp$mhab,     dist=fun, zi_term=dolina$samp$method) dol2 <- opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=fun, zi_term=dolina$samp$method) summary(dol2) }  ## current collapse value getOption(\"ocoptions\")$collapse #> [1] \"+\" ## factor levels sometimes need to be manipulated ## before feeding it to opticut fix_levels(as.factor(c(\"A b\", \"C d\")), sep=\":\") #> [1] A b C d #> Levels: A b C d fix_levels(as.factor(c(\"A b\", \"C d\")), sep=\"\") #> [1] A b C d #> Levels: A b C d"},{"path":"/reference/optilevels.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Number of Factor Levels — optilevels","title":"Optimal Number of Factor Levels — optilevels","text":"Finds optimal number factor levels given data model using likelihood-based agglomerative algorithm.","code":""},{"path":"/reference/optilevels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal Number of Factor Levels — optilevels","text":"","code":"optilevels(y, x, z = NULL, alpha = 0, dist = \"gaussian\", ...)  # S3 method for optilevels bestmodel(object, ...)"},{"path":"/reference/optilevels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Number of Factor Levels — optilevels","text":"y vector observations. x factor matrix proportions (.e. values 0 1 consistent meaning across columns, often unit sum constraint). user's responsibility ensure values supplied x sensible. x expected include intercept. z design matrix predictor variables besides one(s) defined via argument x. user's responsibility ensure values supplied z sensible also makes sense bind x z together. Variables z centered (mean 0) (possibly normalized SD), design matrix x expected include intercept. alpha numeric [0-1], weighting factor calculating information criteria model selection (.e. IC = (1-alpha)*AIC + alpha*BIC, also referred CAIC: consistent AIC). dist character, distribution argument passed underlying functions, see listed help page opticut (except dist = \"zip2\", dist = \"zinb2\" dist = \"rsf\", dist = \"rspf\"). object fitted object. ... arguments passed underlying functions, see opticut1.","code":""},{"path":"/reference/optilevels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal Number of Factor Levels — optilevels","text":"object class 'optilevels' list following elements: \"delta\" delta IC values along selection path considering best models. \"ic\" IC values along selection path considering best models. \"coef\" matrix coefficients (linear predictor scale) corresponding argument x along selection path considering best models. \"zcoef\" matrix coefficients (linear predictor scale) corresponding argument z NULL along selection path considering best models, NULL. \"rank\" matrix ranks based coefficients along selection path considering best models. Ranking uses default ties.method = \"average\" rank. \"deltalist\" delta IC values along selection path considering competing models. \"iclist\" IC values along selection path considering competing models. \"coeflist\" matrix coefficients (linear predictor scale) corresponding argument x along selection path considering competing models. \"zcoeflist\" matrix coefficients (linear predictor scale) corresponding argument z NULL along selection path considering competing models, NULL. \"ranklist\" matrix ranks based coefficients along selection path considering competing models. \"levels\" list (merged) factor levels along selection path considering best models. \"Y\" vector observations (argument y). \"X\" design matrix component corresponding argument x. \"Z\" design matrix component corresponding argument z. \"alpha\" weighting argument. \"dist\" distribution argument. \"factor\" logical, indicating argument x factor (TRUE) matrix (FALSE). bestmodel returns best supported model manipulation (e.g. prediction).","code":""},{"path":"/reference/optilevels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Optimal Number of Factor Levels — optilevels","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/optilevels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Number of Factor Levels — optilevels","text":"","code":"## --- Factor levels with Gaussian distribution ## simple example from Legendre 2013 ## Indicator Species: Computation, in ## Encyclopedia of Biodiversity, Volume 4 ## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5 gr <- as.factor(paste0(\"X\", rep(1:5, each=5))) spp <- cbind(Species1=rep(c(4,6,5,3,2), each=5),     Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),     Species3=rep(c(18,2,0,0,0), each=5)) rownames(spp) <- gr ## must add some noise to avoid perfect fit spp[6, \"Species1\"] <- 7 spp[1, \"Species3\"] <- 17 spp #>    Species1 Species2 Species3 #> X1        4        8       17 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X1        4        8       18 #> X2        7        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X2        6        4        2 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X3        5        6        0 #> X4        3        4        0 #> X4        3        4        0 #> X4        3        2        0 #> X4        3        0        0 #> X4        3        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0 #> X5        2        0        0  ol <- optilevels(spp[,\"Species3\"], gr) ol[c(\"delta\", \"coef\", \"rank\", \"levels\")] #> $delta #> [1]  0 -4 NA NA NA #>  #> $coef #>        X1 X2 X3 X4 X5 #> [1,] 17.8  2  0  0  0 #> [2,] 17.8  2  0  0  0 #> [3,]   NA NA NA NA NA #> [4,]   NA NA NA NA NA #> [5,]   NA NA NA NA NA #>  #> $rank #>      X1 X2 X3 X4 X5 #> [1,]  5  4  2  2  2 #> [2,]  3  2  1  1  1 #> [3,] NA NA NA NA NA #> [4,] NA NA NA NA NA #> [5,] NA NA NA NA NA #>  #> $levels #> $levels[[1]] #>         X1         X2         X3         X4         X5  #>       \"X1\"       \"X2\" \"X3+X4+X5\" \"X3+X4+X5\" \"X3+X4+X5\"  #>  #> $levels[[2]] #>         X1         X2         X3         X4         X5  #>       \"X1\"       \"X2\" \"X3+X4+X5\" \"X3+X4+X5\" \"X3+X4+X5\"  #>  #>   ## get the final factor level gr1 <- gr levels(gr1) <- ol$level[[length(ol$level)]] table(gr, gr1) #>     gr1 #> gr   X1 X2 X3+X4+X5 #>   X1  5  0        0 #>   X2  0  5        0 #>   X3  0  0        5 #>   X4  0  0        5 #>   X5  0  0        5  ## compare the models o0 <- lm(spp[,\"Species3\"] ~ gr - 1) o1 <- lm(spp[,\"Species3\"] ~ gr1 - 1) data.frame(AIC(o0, o1), delta=AIC(o0, o1)$AIC - AIC(o0)) #>    df       AIC delta #> o0  6 -3.103558     0 #> o1  4 -7.103558    -4 ol$delta # should be identical #> [1]  0 -4 NA NA NA  ## --- Proportions with Poisson distribution ## simulation set.seed(123) n <- 500 # number of observations k <- 5 # number of habitat types b <- c(-1, -0.2, -0.2, 0.5, 1) names(b) <- LETTERS[1:k] x <- replicate(k, exp(rnorm(n))) x <- x / rowSums(x) # proportions X <- model.matrix(~.-1, data=data.frame(x)) lam <- exp(drop(crossprod(t(X), b))) y <- rpois(n, lam)  z <- optilevels(y, x, dist=\"poisson\")  ## best model refit bestmodel(z) #>  #> Call:  stats::glm(formula = Y ~ . - 1, family = Family, data = XX) #>  #> Coefficients: #>      X1  `X2+X3`       X4       X5   #> -0.8941  -0.3098   0.5044   1.0391   #>  #> Degrees of Freedom: 500 Total (i.e. Null);  496 Residual #> Null Deviance:\t    586.2  #> Residual Deviance: 548.4 \tAIC: 1297  ## estimates plogis(z$coef) #>             X1        X2        X3        X4       X5 #> [1,] 0.2880184 0.3761074 0.4665556 0.6289233 0.737896 #> [2,] 0.2902740 0.4231689 0.4231689 0.6234846 0.738678 #> [3,]        NA        NA        NA        NA       NA #> [4,]        NA        NA        NA        NA       NA #> [5,]        NA        NA        NA        NA       NA plogis(b) #>         A         B         C         D         E  #> 0.2689414 0.4501660 0.4501660 0.6224593 0.7310586  ## optimal classification z$rank #>      X1 X2 X3 X4 X5 #> [1,]  1  2  3  4  5 #> [2,]  1  2  2  3  4 #> [3,] NA NA NA NA NA #> [4,] NA NA NA NA NA #> [5,] NA NA NA NA NA  ## get the final matrix x1 <- mefa4::groupSums(x, 2, z$levels[[length(z$levels)]]) head(x) #>           [,1]       [,2]       [,3]       [,4]       [,5] #> [1,] 0.2258750 0.21671095 0.14615367 0.17407228 0.23718812 #> [2,] 0.2256225 0.10514521 0.10039234 0.20888497 0.35995493 #> [3,] 0.4995209 0.29345552 0.10323013 0.04264214 0.06115135 #> [4,] 0.1150706 0.22726090 0.09395935 0.20075919 0.36294998 #> [5,] 0.1998835 0.03883339 0.01372342 0.53850776 0.20905194 #> [6,] 0.3048449 0.04987853 0.15529267 0.46033369 0.02965023 head(x1) #>             X1      X2+X3         X4         X5 #> [1,] 0.2258750 0.36286462 0.17407228 0.23718812 #> [2,] 0.2256225 0.20553755 0.20888497 0.35995493 #> [3,] 0.4995209 0.39668566 0.04264214 0.06115135 #> [4,] 0.1150706 0.32122025 0.20075919 0.36294998 #> [5,] 0.1998835 0.05255681 0.53850776 0.20905194 #> [6,] 0.3048449 0.20517120 0.46033369 0.02965023  ## compare the models m0 <- glm(y ~ x - 1, family=\"poisson\") m1 <- glm(y ~ x1 - 1, family=\"poisson\") data.frame(AIC(m0, m1), delta=AIC(m0, m1)$AIC - AIC(m0)) #>    df      AIC     delta #> m0  5 1298.452  0.000000 #> m1  4 1297.381 -1.071501 z$delta # should be identical #> [1]  0.000000 -1.071501        NA        NA        NA  if (FALSE) { ## dolina example with factor data(dolina) dolina$samp$stratum <- as.integer(dolina$samp$stratum) y <- dolina$xtab[dolina$samp$method == \"Q\", \"ppyg\"] x <- dolina$samp$mhab[dolina$samp$method == \"Q\"] z <- scale(model.matrix(~ stratum + lmoist - 1,     dolina$samp[dolina$samp$method == \"Q\",]))  ## without additional covariates dol1 <- optilevels(y, x, z=NULL, dist=\"poisson\") dol1$rank summary(bestmodel(dol1))  ## with additional covariates dol2 <- optilevels(y, x, z, dist=\"poisson\") dol2$rank summary(bestmodel(dol2))  ## compare the two models AIC(bestmodel(dol1), bestmodel(dol2)) }"},{"path":"/reference/rankComb.html","id":null,"dir":"Reference","previous_headings":"","what":"Ranking Based Binary Partitions — rankComb","title":"Ranking Based Binary Partitions — rankComb","text":"Blindly fitting model possible partitions wasteful use resources. Instead, one can rank K levels (strata) based expected response values explore K-1 binary partitions along gradient defined ranks expected values.","code":""},{"path":"/reference/rankComb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ranking Based Binary Partitions — rankComb","text":"","code":"oComb(x, collapse) rankComb(Y, X, Z, dist = \"gaussian\", collapse, ...)"},{"path":"/reference/rankComb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ranking Based Binary Partitions — rankComb","text":"Y numeric, vector observations. X numeric, design matrix. Z factor, must least 2 unique levels. dist character, distribution argument passed underlying functions, see listed help page opticut. x numeric vector. collapse character, paste levels. Defaults getOption(\"ocoptions\")$collapse. ... arguments passed underlying functions, see opticut.","code":""},{"path":"/reference/rankComb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Ranking Based Binary Partitions — rankComb","text":"oComb returns 'contrast' matrix based rank vector input. Ranked lowest highest expected value among partitions. function rankComb fits model multiple (K > 2) factor levels find ranking, returns binary classification matrix returned oComb corresponding ranking.","code":""},{"path":"/reference/rankComb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Ranking Based Binary Partitions — rankComb","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/rankComb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Ranking Based Binary Partitions — rankComb","text":"","code":"## simulate some data set.seed(1234) n <- 200 x0 <- sample(1:4, n, TRUE) x1 <- ifelse(x0 %in% 1:2, 1, 0) x2 <- rnorm(n, 0.5, 1) lam <- exp(0.5 + 0.5*x1 + -0.2*x2) Y <- rpois(n, lam)  ## binary partitions head(rc <- rankComb(Y, model.matrix(~x2), as.factor(x0), dist=\"poisson\")) #>   2 1+2 1+2+4 #> 4 0   0     1 #> 4 0   0     1 #> 2 1   1     1 #> 2 1   1     1 #> 1 0   1     1 #> 4 0   0     1 attr(rc, \"est\") # expected values in factor levels #>        1        2        3        4  #> 2.767840 2.792267 1.563285 1.757870  aggregate(exp(0.5 + 0.5*x1), list(x0=x0), mean) # true values #>   x0        x #> 1  1 2.718282 #> 2  2 2.718282 #> 3  3 1.648721 #> 4  4 1.648721  ## simple example oComb(1:4, \"+\") #>   1 1+2 1+2+3 #> 1 1   1     1 #> 2 0   1     1 #> 3 0   0     1 #> 4 0   0     0 ## using estimates oComb(attr(rc, \"est\")) #>   3 3+4 1+3+4 #> 1 0   0     1 #> 2 0   0     0 #> 3 1   1     1 #> 4 0   1     1"},{"path":"/reference/uncertainty.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantifying Uncertainty for Fitted Objects — uncertainty","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"Quantifying uncertainty fitted objects.","code":""},{"path":"/reference/uncertainty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"","code":"uncertainty(object, ...) # S3 method for opticut uncertainty(object,     which = NULL, type = c(\"asymp\", \"boot\", \"multi\"),     B = 99, cl = NULL, ...) # S3 method for multicut uncertainty(object,     which = NULL, type = c(\"asymp\", \"boot\"),     B = 99, cl = NULL, ...)  check_strata(x, mat) # S3 method for uncertainty strata(object, ...) # S3 method for uncertainty subset(x, subset=NULL, ...)  # S3 method for uncertainty bestpart(object, ...) # S3 method for uncertainty1 bestpart(object, ...)  # S3 method for uncertainty1 print(x, ...) # S3 method for uncertainty print(x, ...) # S3 method for summary.uncertainty print(x, sort, digits, ...) # S3 method for uncertainty summary(object, level = 0.95, ...)  # S3 method for uncertainty as.data.frame(x,     row.names = NULL, optional = FALSE, sort, ...) # S3 method for summary.uncertainty as.data.frame(x,     row.names = NULL, optional = FALSE, sort, ...)  # S3 method for uncertainty1 bsmooth(object, ...) # S3 method for uncertainty bsmooth(object, ...)"},{"path":"/reference/uncertainty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"object fitted model object (contain extra arguments part ...), output uncertainty summary method. numeric character (can vector) defining subset species fitted object, NULL (species, default). type character, describing type uncertainty calculation. See Details. B numeric, number iterations. type = \"boot\" type = \"multi\" can user-supplied matrix indices resampling dimensions length observations times B. cl cluster object, integer multiple cores parallel computations (integer value forking ignored Windows). x object printed. level confidence level required. sort logical value indicating species meaningfully sorted, default TRUE. digits numeric, number significant digits output. mat matrix resampling indices (rows samples, columns iterations). row.names NULL character vector giving row names data frame. Missing values allowed. See .data.frame. optional logical. TRUE, setting row names converting column names (syntactic names: see make.names) optional. See .data.frame. subset logical, numeric, character index indicating species keep, missing values accepted. ... arguments passed underlying functions.","code":""},{"path":"/reference/uncertainty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"Uncertainty calculated indicator potential , expected values (mu0, mu1 opticut, mu_* multicut objects). \"asymp\": asymptotic distribution based best supported model (option unavailable custom distribution functions requires Hessian matrix). type available opticut multicut objects. \"boot\": non-parametric bootstrap distribution based best partition found input object. type available opticut multicut objects. \"multi\": non-parametric bootstrap distribution based best partition found bootstrap data (.e. model ranking re-evaluated time). \"multi\" works comb = \"rank\" opticut call. type available multicut objects.","code":""},{"path":"/reference/uncertainty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"uncertainty returns object class 'uncertainty'. uncertainty element object list species specific output elements (object class 'uncertainty1'). 'uncertainty1' output data frame columns: best partition, indicator potential , expected values (mu0, mu1 opticut, mu_* multicut objects). check_strata returns logical vector checking original strata input object represented resampling indices. Number strata attached attributes diagnostics. summary method prints name best supported split, selection frequency (R, reliability), indicator values (, based distribution values within best supported split highest reliability) confidence interval (based level). subset method subsets species uncertainty object. bestpart finds selection frequencies strata best partitions (number strata x number species). coercion method .data.frame returns data frame. bsmooth method returns bootstrap smoothed results strata (available multicut based uncertainty objects, check uncertainty results instead).","code":""},{"path":"/reference/uncertainty.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"Resampling methods can lead complete exclusion certain strata sample size small. Try revising stratification input object, provide custom resampling indices via B argument using stratified (block) bootstrap, jackknife (leave-one-), similar techniques. Finding suitable random seed via set.seed dropping unsuitable iterations can also resolve issue.","code":""},{"path":"/reference/uncertainty.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"Peter Solymos <psolymos@gmail.com>","code":""},{"path":[]},{"path":"/reference/uncertainty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantifying Uncertainty for Fitted Objects — uncertainty","text":"","code":"set.seed(2345) n <- 50 x0 <- sample(1:4, n, TRUE) x1 <- ifelse(x0 %in% 1:2, 1, 0) x2 <- rnorm(n, 0.5, 1) x3 <- ifelse(x0 %in% 2:4, 1, 0) lam1 <- exp(0.5 + 1*x1 + -0.2*x2) Y1 <- rpois(n, lam1) lam2 <- exp(1 + 0.5*x3) Y2 <- rpois(n, lam2) Y3 <- rpois(n, exp(0)) Y <- cbind(Spp1=Y1, Spp2=Y2, Spp3=Y3)  oc <- opticut(Y ~ x2, strata=x0, dist=\"poisson\", comb=\"rank\")  ## asymptotic confidence intervals (uc1 <- uncertainty(oc, type=\"asymp\", B=999)) #> Multivariate multicut uncertainty results, type = asymp, B = 999 #>  summary(uc1) #> Multivariate multicut uncertainty results #> type = asymp, B = 999, level = 0.95 #>  #>      split R      I    Lower  Upper #> Spp1   1+2 1 0.3756 0.205644 0.5150 #> Spp3 1+2+3 1 0.3438 0.016874 0.6984 #> Spp2 2+3+4 1 0.1354 0.007452 0.2944 ## bootstrap-based confidence intervals (uc2 <- uncertainty(oc, type=\"boot\", B=19)) #> Multivariate multicut uncertainty results, type = boot, B = 19 #>  summary(uc2) #> Multivariate multicut uncertainty results #> type = boot, B = 19, level = 0.95 #>  #>      split R      I    Lower  Upper #> Spp1   1+2 1 0.3688 0.266965 0.4710 #> Spp3 1+2+3 1 0.3689 0.023399 0.8796 #> Spp2 2+3+4 1 0.1354 0.003183 0.2706  ## use user-supplied indices ## multi-model bootstrap based uncertainties B <- replicate(25, sample.int(n, replace=TRUE)) check_strata(oc, B) # check representation #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE #> attr(,\"nx\") #> [1] 4 #> attr(,\"nmat\") #>  [1] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 (uc3 <- uncertainty(oc, type=\"multi\", B=B)) #> Multivariate multicut uncertainty results, type = multi, B = 25 #>  summary(uc3) #> Multivariate multicut uncertainty results #> type = multi, B = 25, level = 0.95 #>  #>      split      R      I   Lower Upper #> Spp1   1+2 0.7308 0.3980 0.27604 0.552 #> Spp3 1+2+3 0.3846 0.5624 0.21287 1.000 #> Spp2 2+3+4 0.4615 0.1760 0.09648 0.266  ## best partitions: ## selection frequencies for strata and species bestpart(uc3) #>        Spp1       Spp2      Spp3 #> 1 1.0000000 0.03846154 0.6538462 #> 2 1.0000000 0.73076923 0.6538462 #> 3 0.0000000 0.92307692 0.8461538 #> 4 0.2692308 0.65384615 0.0000000 heatmap(bestpart(uc3), scale=\"none\", col=occolors()(25))  ## bootstrap smoothed predictions per strata bsmooth(uc3) #>       Spp1     Spp2      Spp3 #> 1 4.242728 3.413736 0.6399826 #> 2 4.242728 4.330780 0.6884190 #> 3 1.808303 4.583842 0.7642625 #> 4 2.429689 4.188160 0.3545554 heatmap(bestpart(uc3), scale=\"none\", col=occolors()(25))   ## individual species results uc3$uncertainty #> $Spp1 #> Univariate multicut uncertainty results, type = multi, B = 25 #>  #>      best                 I               mu0             mu1        #>  Length:26          Min.   :0.2675   Min.   :1.159   Min.   :3.436   #>  Class :character   1st Qu.:0.3360   1st Qu.:1.502   1st Qu.:3.974   #>  Mode  :character   Median :0.4088   Median :1.777   Median :4.184   #>                     Mean   :0.4065   Mean   :1.808   Mean   :4.243   #>                     3rd Qu.:0.4719   3rd Qu.:2.108   3rd Qu.:4.405   #>                     Max.   :0.5892   Max.   :2.764   Max.   :5.502   #>  #> $Spp2 #> Univariate multicut uncertainty results, type = multi, B = 25 #>  #>      best                 I               mu0             mu1        #>  Length:26          Min.   :0.0258   Min.   :2.312   Min.   :3.844   #>  Class :character   1st Qu.:0.1105   1st Qu.:3.097   1st Qu.:4.400   #>  Mode  :character   Median :0.1344   Median :3.359   Median :4.659   #>                     Mean   :0.1559   Mean   :3.394   Mean   :4.627   #>                     3rd Qu.:0.2209   3rd Qu.:3.724   3rd Qu.:4.944   #>                     Max.   :0.2813   Max.   :4.225   Max.   :5.321   #>  #> $Spp3 #> Univariate multicut uncertainty results, type = multi, B = 25 #>  #>      best                 I               mu0              mu1         #>  Length:26          Min.   :0.1554   Min.   :0.0000   Min.   :0.6147   #>  Class :character   1st Qu.:0.2951   1st Qu.:0.2790   1st Qu.:0.6926   #>  Mode  :character   Median :0.3702   Median :0.3674   Median :0.7865   #>                     Mean   :0.4280   Mean   :0.3546   Mean   :0.8334   #>                     3rd Qu.:0.4884   3rd Qu.:0.4624   3rd Qu.:0.9216   #>                     Max.   :1.0000   Max.   :0.6937   Max.   :1.7098   #>  bestpart(uc3$uncertainty[[1]]) #>   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14] #> 1    1    1    1    1    1    1    1    1    1     1     1     1     1     1 #> 2    1    1    1    1    1    1    1    1    1     1     1     1     1     1 #> 3    0    0    0    0    0    0    0    0    0     0     0     0     0     0 #> 4    0    0    0    0    0    0    0    0    0     0     1     0     0     1 #>   [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26] #> 1     1     1     1     1     1     1     1     1     1     1     1     1 #> 2     1     1     1     1     1     1     1     1     1     1     1     1 #> 3     0     0     0     0     0     0     0     0     0     0     0     0 #> 4     0     1     0     1     0     1     1     0     0     0     1     0 bsmooth(uc3$uncertainty[[1]]) #>       [,1]     [,2]     [,3]     [,4]     [,5]     [,6]     [,7]     [,8] #> 1 4.353309 4.123784 4.796411 5.502443 4.966979 3.956581 4.263636 4.066393 #> 2 4.353309 4.123784 4.796411 5.502443 4.966979 3.956581 4.263636 4.066393 #> 3 1.968847 1.752355 2.048311 1.802075 2.764274 1.307073 2.327590 2.026677 #> 4 1.968847 1.752355 2.048311 1.802075 2.764274 1.307073 2.327590 2.026677 #>       [,9]    [,10]    [,11]    [,12]    [,13]    [,14]    [,15]    [,16] #> 1 4.547626 4.154616 3.436177 4.320181 4.421835 3.510415 4.258540 3.983873 #> 2 4.547626 4.154616 3.436177 4.320181 4.421835 3.510415 4.258540 3.983873 #> 3 2.368197 1.727303 1.399548 2.128446 1.869369 1.312151 1.990268 1.277240 #> 4 2.368197 1.727303 3.436177 2.128446 1.869369 3.510415 1.990268 3.983873 #>      [,17]    [,18]    [,19]    [,20]    [,21]    [,22]    [,23]    [,24] #> 1 3.906009 3.714836 3.921941 4.242182 4.214182 4.605661 3.970598 4.998947 #> 2 3.906009 3.714836 3.921941 4.242182 4.214182 4.605661 3.970598 4.998947 #> 3 2.251073 2.147011 1.628562 2.208800 1.491471 1.532036 1.559550 1.292377 #> 4 2.251073 3.714836 1.628562 4.242182 4.214182 1.532036 1.559550 1.292377 #>      [,25]    [,26] #> 1 4.049467 4.024312 #> 2 4.049467 4.024312 #> 3 1.158853 1.676410 #> 4 4.049467 1.676410  if (FALSE) { ## block bootstrap block_fun <- function()     unlist(lapply(unique(x0), function(z) if (sum(x0==z) < 2)         which(x0==z) else sample(which(x0==z), sum(x0==z), replace=TRUE))) B <- replicate(25, block_fun()) check_strata(oc, B) # check representation summary(uncertainty(oc, type=\"multi\", B=B))  ## jackknife B <- sapply(1:n, function(i) which((1:n) != i)) check_strata(oc, B) # check representation summary(uncertainty(oc, type=\"multi\", B=B))  ## multicut based uncertainty mc <- multicut(Y ~ x2, strata=x0, dist=\"poisson\")  ## asymptotic confidence intervals (muc1 <- uncertainty(mc, type=\"asymp\", B=999)) summary(muc1) bestpart(muc1)  ## bootstrap-based confidence intervals (muc2 <- uncertainty(mc, type=\"boot\", B=19)) summary(muc2) bestpart(muc2)  ## dolina example data(dolina) ## stratum as ordinal dolina$samp$stratum <- as.integer(dolina$samp$stratum) ## filter species to speed up things a bit Y <- ifelse(dolina$xtab[,colSums(dolina$xtab > 0) >= 20] > 0, 1, 0) ## opticut results, note the cloglog link function dol <- opticut(Y ~ stratum + lmoist + method, data=dolina$samp,     strata=dolina$samp$mhab, dist=\"binomial:cloglog\")  ## parallel computing for uncertainty library(parallel) cl <- makeCluster(2) ucdol <- uncertainty(dol, type=\"multi\", B=25, cl=cl) stopCluster(cl)  bestpart(ucdol) heatmap(t(bestpart(ucdol)), scale=\"none\", col=occolors()(25),     distfun=function(x) dist(x, \"manhattan\"))  ## See how indicator value changes with different partitions ## (and why it is the wrong metric to use in this calse) with(ucdol$uncertainty[[\"pvic\"]],     boxplot(I ~ best, col=\"gold\", ylab=\"Indicator value\")) ## What we should calculate is the bootstrap smoothed mean of the ## expected value and its confidence intervals bs <- bsmooth(ucdol$uncertainty[[\"pvic\"]]) boxplot(t(bs), ylab=\"Expected value\") cbind(Mean=rowMeans(bs), t(apply(bs, 1, quantile, probs=c(0.025, 0.975))))  ## A more interesting simulated example for bootstrap smoothing ## and comparing opticut vs. multicut set.seed(1) n <- 2000 x <- sort(runif(n, -8, 8)) p <- plogis(0.5 + -0.1 * x + -0.2 * x^2) y <- rbinom(n, 1, p) d <- diff(range(x))/10 br <- seq(min(x), max(x), by=d) g <- cut(x, br, include.lowest=TRUE) levels(g) <- LETTERS[1:nlevels(g)] o <- opticut(y ~ 1, strata=g, dist=\"binomial\") m <- multicut(y ~ 1, strata=g, dist=\"binomial\") library(parallel) cl <- makeCluster(2) uo <- uncertainty(o, type=\"multi\", B=99, cl=cl) um <- uncertainty(m, type=\"boot\", B=99, cl=cl) stopCluster(cl) ## bootstrap average for opticut bs <- bsmooth(uo$uncertainty[[1]]) stat <- cbind(Mean=rowMeans(bs),     t(apply(bs, 1, quantile, probs=c(0.025, 0.975)))) ## bootstrap average for multicut bsm <- as.matrix(um$uncertainty[[1]][,-(1:2)]) statm <- cbind(Mean=colMeans(bsm),     t(apply(bsm, 2, quantile, probs=c(0.025, 0.975))))  op <- par(mfrow=c(2,1)) plot(p ~ x, type=\"l\", ylim=c(0,1), main=\"Binary partitions (opticut)\") abline(v=br, col=\"grey\", lty=3) lines(br[-1]-0.5*d, stat[,1], col=4) lines(br[-1]-0.5*d, stat[,2], col=4, lty=2) lines(br[-1]-0.5*d, stat[,3], col=4, lty=2) lines(br[-1]-0.5*d, bs[,1], col=2) legend(\"topright\", bty=\"n\", lty=c(1,1,2,1), col=c(1,4,4,2),     legend=c(\"True response\",\"bsmooth\",\"0.95 CI\",\"Best partition\"))  plot(p ~ x, type=\"l\", ylim=c(0,1), main=\"Multi-level model (multicut)\") abline(v=br, col=\"grey\", lty=3) lines(br[-1]-0.5*d, statm[,1], col=4) lines(br[-1]-0.5*d, statm[,2], col=4, lty=2) lines(br[-1]-0.5*d, statm[,3], col=4, lty=2) legend(\"topright\", bty=\"n\", lty=c(1,1,2), col=c(1,4,4),     legend=c(\"True response\",\"bsmooth\",\"0.95 CI\")) par(op) }"},{"path":"/reference/warblers.html","id":null,"dir":"Reference","previous_headings":"","what":"Warblers Data Set — warblers","title":"Warblers Data Set — warblers","text":"Five species warblers studied determine factors controlling species abundances competition (MacArthur 1958).","code":""},{"path":"/reference/warblers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Warblers Data Set — warblers","text":"","code":"data(\"warblers\")"},{"path":"/reference/warblers.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Warblers Data Set — warblers","text":"list 3 elements: xtab list sample x species matrices (sec_prc: percentages total number seconds observations, num_prc: percentages total number observations seconds, sec_cnt: counts based percentages totals seconds, num_cnt: counts based percentages totals), samp data frame sample level attributes height (6 base, 1 top trees, trees 50--60 feet tall) depth branches canopy (B: bare lichen- covered base, M: middle zone old needles, T: terminal zone new, less 1.5 years old, needles buds) , taxa data frame scientific common names species.","code":""},{"path":"/reference/warblers.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Warblers Data Set — warblers","text":"MacArthur 1958.","code":""},{"path":"/reference/warblers.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Warblers Data Set — warblers","text":"MacArthur, R. H., 1958. Population ecology warblers northeastern coniferous forests. Ecology 39:599--619. <doi:10.2307/1931600>","code":""},{"path":"/reference/warblers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Warblers Data Set — warblers","text":"","code":"data(warblers) str(warblers) #> List of 3 #>  $ xtab:List of 4 #>   ..$ sec_prc: num [1:16, 1:5] 43.8 13.8 0 21.3 11.2 0 5 1.2 0 0 ... #>   .. ..- attr(*, \"dimnames\")=List of 2 #>   .. .. ..$ : chr [1:16] \"B1\" \"M1\" \"T1\" \"B2\" ... #>   .. .. ..$ : chr [1:5] \"CMWA\" \"YRWA\" \"BTNW\" \"BLBW\" ... #>   ..$ num_prc: num [1:16, 1:5] 43.8 13.8 0 21.3 11.2 0 5 1.2 0 0 ... #>   .. ..- attr(*, \"dimnames\")=List of 2 #>   .. .. ..$ : chr [1:16] \"B1\" \"M1\" \"T1\" \"B2\" ... #>   .. .. ..$ : chr [1:5] \"CMWA\" \"YRWA\" \"BTNW\" \"BLBW\" ... #>   ..$ sec_cnt: int [1:16, 1:5] 1292 342 0 533 215 0 104 13 0 0 ... #>   .. ..- attr(*, \"dimnames\")=List of 2 #>   .. .. ..$ : chr [1:16] \"B1\" \"M1\" \"T1\" \"B2\" ... #>   .. .. ..$ : chr [1:5] \"CMWA\" \"YRWA\" \"BTNW\" \"BLBW\" ... #>   ..$ num_cnt: int [1:16, 1:5] 35 11 0 17 9 0 4 1 0 0 ... #>   .. ..- attr(*, \"dimnames\")=List of 2 #>   .. .. ..$ : chr [1:16] \"B1\" \"M1\" \"T1\" \"B2\" ... #>   .. .. ..$ : chr [1:5] \"CMWA\" \"YRWA\" \"BTNW\" \"BLBW\" ... #>  $ samp:'data.frame':\t16 obs. of  3 variables: #>   ..$ zone  : Factor w/ 16 levels \"B1\",\"M1\",\"T1\",..: 1 2 3 4 5 6 7 8 9 10 ... #>   ..$ height: int [1:16] 1 1 1 2 2 2 3 3 3 4 ... #>   ..$ depth : Factor w/ 3 levels \"B\",\"M\",\"T\": 1 2 3 1 2 3 1 2 3 1 ... #>  $ taxa:'data.frame':\t5 obs. of  2 variables: #>   ..$ scientific: Factor w/ 5 levels \"Setophaga castanea\",..: 4 2 5 3 1 #>   ..$ common    : Factor w/ 5 levels \"Bay-breasted Warbler\",..: 4 5 2 3 1  warbh <- mefa4::groupSums(warblers$xtab$num_cnt, 1, warblers$samp$height) warbd <- mefa4::groupSums(warblers$xtab$num_cnt, 1, warblers$samp$depth) op <- par(mfrow=c(1,2)) matplot(rownames(warbh), warbh, type=\"b\", xlab=\"height\") matplot(warbd, type=\"b\", axes=FALSE, xlab=\"depth\") box() axis(2) axis(1, 1:3, rownames(warbd))  par(op)"},{"path":"/news/index.html","id":"version-01-4--may-21-2024","dir":"Changelog","previous_headings":"","what":"Version 0.1-4 – May 21, 2024","title":"Version 0.1-4 – May 21, 2024","text":"Maintainer email change.","code":""},{"path":"/news/index.html","id":"version-01-3--mar-27-2018","dir":"Changelog","previous_headings":"","what":"Version 0.1-3 – Mar 27, 2018","title":"Version 0.1-3 – Mar 27, 2018","text":"warblers data set added based MacArthur 1958.","code":""},{"path":"/news/index.html","id":"version-01-2--feb-1-2018","dir":"Changelog","previous_headings":"","what":"Version 0.1-2 – Feb 1, 2018","title":"Version 0.1-2 – Feb 1, 2018","text":"CRAN release: 2018-02-01 option robust_loglik safeguards ill-defined (.e. infinite) log likelihoods can result e.g. perfect fit.","code":""},{"path":"/news/index.html","id":"version-01-1--jan-30-2018","dir":"Changelog","previous_headings":"","what":"Version 0.1-1 – Jan 30, 2018","title":"Version 0.1-1 – Jan 30, 2018","text":"CRAN release: 2018-01-31 multicut added multi-level response model. fitted predict methods added. New data set: birdrec bird detections. wrsi sindex functions migrated ResourceSelection package.","code":""},{"path":"/news/index.html","id":"version-01-0--dec-16-2016","dir":"Changelog","previous_headings":"","what":"Version 0.1-0 – Dec 16, 2016","title":"Version 0.1-0 – Dec 16, 2016","text":"CRAN release: 2016-12-17 1st CRAN release binary optimal partitioning.","code":""},{"path":"/news/index.html","id":"version-00-1--nov-22-2015-not-on-cran","dir":"Changelog","previous_headings":"","what":"Version 0.0-1 – Nov 22, 2015 (not on CRAN)","title":"Version 0.0-1 – Nov 22, 2015 (not on CRAN)","text":"Organizing files checking package.","code":""}]
